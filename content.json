[{"title":"github+hexo 搭建个人博客","date":"2016-12-22T08:59:26.000Z","path":"2016/12/22/github+hexo 搭建个人博客/","text":"安装准备： github账号（用户名sniperyen） github上的一个仓库（仓库名sniperyen.github.io=用户名sniperyen+.github.io） homebrew（mac电脑上的工具） 安装 nodejs1234567# mac中安装brew tap homebrew/versions # 安装homebrew-versionbrew install homebrew/versions/node # 查看可安装的node版本brew install homebrew/versions/node5 # 选择一个版本的node安装# ubuntu中安装sudo apt-get install nodejs npm设置源npm是nodejs的包管理软件，类似于python中的pip，但其在国内安装速度太坑爹，故用第三方插件，可以更改源地址。 123456789101112# 安装npm install -g nrm# 查看源列表nrm ls* npm ----- https://registry.npmjs.org/ cnpm ---- http://r.cnpmjs.org/ taobao -- https://registry.npm.taobao.org/ nj ------ https://registry.nodejitsu.com/ rednpm -- http://registry.mirror.cqupt.edu.cn skimdb -- https://skimdb.npmjs.com/registry# 切换源nrm use cnpm 初始化安装123456789101112131415sudo npm install -g hexo # 安装 hexonpm install hexo-deployer-git --save # hexo部署包cd ~/devmkdir blogcd bloghexo init # 初始化工作目录hexo g # 生成静态页面hexo s # 启动本地调试服务器# 下面几个扩展包按需安装npm install hexo-renderer-less --save npm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-json-content --save 配置博客hexo的目录和文件： 1、 scaffolds ：模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件。Hexo 有三种默认布局： post 、 page 和 draft ，它们分别对应不同的路径。新建文件的默认布局是 post ，可以在配置文件中更改布局。用 draft 布局生成的文件会被保存到 source/_drafts 文件夹。 2、 source ：资源文件夹是存放用户资源的地方。 3、 source/_post ：文件箱。（低版本的hexo还会存在一个 _draft ，这是草稿箱）除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 4、 themes ：主题 文件夹。Hexo 会根据主题来生成静态页面。 5、 themes/landscape ：默认的皮肤文件夹 6、 _config.yml ：全局的配置文件，每次更改要重启服务。 低版本的Hexo还会生成scripts文件夹，里面用于保存扩展Hexo的脚本文件。 全局配置根目录下的 _config.yml 负责全局的相关配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 站点配置title: Hexo-demo #网站标题subtitle: hexo is simple and easy to study #网站副标题description: this is hexo-demo #网栈描述author: pomy #你的名字language: zh-CN #网站使用的语言timezone: Asia/Shanghai #网站时区# URL #可以不用配置## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #网址，搜索时会在搜索引擎中显示root: / #网站根目录permalink: :year/:month/:day/:title/ #永久链接格式permalink_defaults: #永久链接中各部分的默认值# Directory 目录配置source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 来配置路径# Writing 写作配置new_post_name: :title.md # 新文章的文件名称default_layout: post #默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #是否启动资源文件夹relative_link: false #把链接改为与根目录的相对位址future: true#代码块的设置highlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tag 分类 &amp; 标签default_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format 时间和日期## Hexo uses Moment.js to parse and display date. You can customize the date format as defined in http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page #分页目录# Extensions 扩展## Plugins: http://hexo.io/plugins/ 插件## Themes: http://hexo.io/themes/ 主题theme: landscape #当前主题名称# Deployment #部署到github## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/sniperyen/sniperyen.github.io.git branch: master 修改全局配置时，注意缩进，同时注意冒号后面要有一个空格。 单页配置在md文件头的设置：1234title: 博客标题tags: [标签一,标签二]date: 2015-12-12 10:50:37 # 如果不设置此项，时间显示deploy的时间；如果不想显示时间，设置 noDate: \"true\"comments: false # 不显示评论 主题配置主题的配置文件在 /themes/主题文件夹/_config.yml ，一般包括导航配置(menu)，内容配置(content)，评论插件，图片效果(fancybox)和边栏(sidebar)。 安装方法 更多主题 常用部署步骤1234hexo n \"新文章\"hexo cleanhexo generatehexo deploy 添加相册 webpack的安装和配置http://2914905399.iteye.com/blog/2314533 添加自定义相册http://www.cnblogs.com/jarson-7426/p/5515870.html 添加访问次数统计功能参考： http://ibruce.info/2013/12/22/count-views-of-hexo/ 连接自己的域名 在source中新建一CNAME文件，写入自己的域名不带www 在阿里云或其他云平台设置域名，一个A解析，一个cname解析 如何使一些不变的文件在部署时不被删除将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等。 不处理source目录的个别文件可以通过在 _config.yml设置skip_render来忽略的目录，具体如下123skip_render: - 'demo/*.html' - 'demo/**' 错误处理 ERROR Plugin load failed: hexo-generator-json-content 解决方案： sudo npm install dtrace-provider","tags":[{"name":"mac","slug":"mac","permalink":"http://woshijingshenbing.com/tags/mac/"},{"name":"hexo","slug":"hexo","permalink":"http://woshijingshenbing.com/tags/hexo/"},{"name":"nodejs","slug":"nodejs","permalink":"http://woshijingshenbing.com/tags/nodejs/"}]},{"title":"MongoDB 随记","date":"2016-12-21T05:04:35.000Z","path":"2016/12/21/MongoDB-随记/","text":"基本操作 启动mongo服务:mongod –dbpath=/data/db –logpath=/data/log/r3.log –fork 进入mongo交互界面:mongo 进入交互界面直接转到 test 数据库，可以这样写: mongo test 查看数据库:show dbs 转到数据库:use test 删除当前数据库:db.dropDatabase() 查看当前数据库下的表:show collections 建表:db.createCollection(“mycoll”) 删表:db.mycoll.drop() 不用写建库或者建表语句,如下面示例,则新建了一个newDB的数据库,其中有张newTable表,有x和y两列.use newDB --&gt; j={x:1,&quot;y&quot;:&quot;school&quot;} --&gt; db.newTable.save(j) 当我们往一个集合中写入一条文档时，系统会自动生成一个名为_id的key.字段类型默认是 ObjectId. 然而_id的类型可以自由指定,但是在同一个集合中必须唯一，如果插入重复的值的话，系统将会抛出异常 A simple example:123456&gt; use test&gt; for( var i = 1; i &lt; 100; i++ ) db.things.save( &#123; x:4, j:i &#125; ); &gt; var cursor = db.things.find(); #var不可以缺&gt; while (cursor.hasNext()) printjson(cursor.next()); #循环输出，也可以这样写 db.things.find().forEach(printjson);&gt; printjson(cursor[4]); #可以把游标当作数组来使用.&gt; var arr = db.things.find().toArray(); #可以转换成数组 使用游标时候请注意占用内存的问题, 特别是很大的游标对象, 有可能会内存溢出. 所以应该用迭代的方式来输出. sql语句–MongoDB shell中语句 普通查询SELECT * FROM things WHERE name=”mongo” and version=”1.6”db.things.find({name:”mongo”,version:”1.6”}).forEach(printjson); 返回特定元素SELECT j FROM things WHERE x=4db.things.find({x:4}, {j:true}).forEach(printjson); 返回一条数据SELECT TOP 1 * FROM things WHERE name=”mongo”db.things.findOne({name:”mongo”}) 限制结果集的长度SELECT TOP 3 * FROM thingsdb.things.find().limit(3); ★修改某条记录(这里有点不一样,mongo会把这条记录重写,而不是单独修改某些字段)UPDATE things SET name=”mongo_new” WHERE name=”mongo”db.things.update({name:”mongo”},{$set:{name:”mongo_new”}}); 删除DELETE FROM things WHERE name=”mongo_new”db.things.remove({name:”mongo_new”}); 条件操作符 &lt;, &lt;=, &gt;, &gt;=, !=12345db.collection.find(&#123; \"field\" : &#123; $gt: value &#125; &#125; ); // 大于: field &gt; value db.collection.find(&#123; \"field\" : &#123; $lt: value &#125; &#125; ); // 小于: field &lt; value db.collection.find(&#123; \"field\" : &#123; $gte: value &#125; &#125; ); // 大于等于: field &gt;= value db.collection.find(&#123; \"field\" : &#123; $lte: value &#125; &#125; ); // 小于等于: field &lt;= value db.collection.find(&#123; \"field\" : &#123; $ne: value &#125; &#125; ); // 不等于: field != value 如果要同时满足多个条件，可以这样做db.collection.find({ &quot;field&quot; : { $gt: value1, $lt: value2 } } ); // value1 &lt; field &lt; value $all 匹配所有这个操作符跟 SQL 语法的 in 类似，但不同的是, in 只需满足( )内的某一个值即可, 而$all 必须满足[ ]内的所有值，例如:db.users.find({age : {$all : [6, 8]}});可以查询出 {name: &#39;David&#39;, age: 26, age: [ 6, 8, 9 ] }但查询不出 {name: &#39;David&#39;, age: 26, age: [ 6, 7, 9 ] } $in 包含与sql标准语法的用途是一样的，即要查询的是一系列枚举值的范围内查询 x 的值在 2,4,6 范围内的数据db.things.find({x:{$in: [2,4,6]}}); $nin 不包含查询 x 的值在 2,4,6 范围外的数据db.things.find({x:{$nin: [2,4,6]}}); $exists 判断字段是否存在查询所有存在 age 字段的记录db.users.find({age: {$exists: true}});查询所有不存在 name 字段的记录db.users.find({name: {$exists: false}}); Null 值处理mongo里面某个元素为NULL,可能是这个键不存在,也可能是键对应的值不存在,所以需要双重判断下db.c2.find({age:{&quot;$in&quot;:[null], &quot;$exists&quot;:true}}) $mod 取模运算(就是余数)查询age取模10等于0的数据,如下,age等于11/21/31…类似的数据会被取出来db.student.find( { age: { $mod : [ 10 , 1 ] } } ) $size 数组元素个数对于{name: &#39;David&#39;, age: 26, favorite_number: [ 6, 7, 9 ] }记录匹配 db.users.find({favorite_number: {$size: 3}});不匹配 db.users.find({favorite_number: {$size: 2}}); 正则表达式匹配查询不匹配 name=B*带头的记录db.users.find({name: {$not: /^B.*/}}); Javascript 查询和$where 查询查询a大于3的数据，下面的查询方法殊途同归 1234db.c1.find( &#123; a : &#123; $gt: 3 &#125; &#125; ); db.c1.find( &#123; $where: \"this.a &gt; 3\" &#125; ); db.c1.find(\"this.a &gt; 3\"); f = function() &#123; return this.a &gt; 3; &#125; db.c1.find(f); skip 限制返回记录的起点从第 3 条记录开始，返回 5 条记录(limit 3, 5)db.users.find().skip(3).limit(5) count 查询记录条数db.users.find().count(); 或者 db.users.count();以下返回的不是5,而是user表中所有的记录数量db.users.find().skip(10).limit(5).count();如果要返回限制之后的记录数量，要使用 count(true)或者 count(非 0)db.users.find().skip(10).limit(5).count(true); sort 排序以年龄升序 ascdb.users.find().sort({age: 1});以年龄降序 descdb.users.find().sort({age: -1}); 存储过程mongo中存储过程是用js写的,万能的javascript…12345&gt; db.system.js.save(&#123;_id:\"addNumbers\", value:function(x, y)&#123; return x + y; &#125;&#125;);&gt; db.evel(\"addNumbers(2,3)\");&gt; db.eval( function() &#123; return 3+3; &#125; ); #db.eval()是一个比较奇怪的东西，我们可以将存储过程的逻辑直接在里面并同时调用，而无需事先声明存储过程的逻辑db.system.js.save(&#123;_id:\"get_count\", value:function()&#123; return db.c1.count(); &#125;&#125;); #可以直接读取库中其他表的信息,或者修改删除等工作皆可. Capped(封顶) Collection介绍:capped collections 是性能出色的有着固定大小的集合，以 LRU(Least Recently Used 最近最少使用)规则和插入顺序进行 age-out(老化移出)处理，自动维护集合中对象的插入顺序，在创建时要预先指定大小。如果空间用完，新添加的对象将会取代集合中最旧的对象。作用:logging、cache、autoarchiving建议： 为了发挥capped collection的最大性能，如果写比读多，最好不要在上面建索引，否则插入速度从”log speed”降为”database speed”。 使用”nature ordering”可以有效地检索最近插入的元素，因为 capped collection 能够保证自然排序就是插入时的顺序，类似于 log 文件上的 tail(尾随) 操作。12&gt; db.createCollection(\"mycoll\", &#123;capped:true, size:100000, max:100&#125;); #创建集合是一定要指定size和max,因为总是先检查size,后检查maxRowNumber; max为1时,不限量存放&gt; db.mycoll.validate(); createCollection 也可以创建普通的集合,还有一个参数”autoIndexID”，决定是否自动创建索引.db.createCollection(“mycoll”, {size:10000000, autoIndexId:false})。默认情况下对一般的 collection 是创建索引的，但不会对 capped collection 创建。 GridFSGridFS 是一种将大型文件存储在 MongoDB 数据库中的文件规范。GridFS 使用两个表来存储数据： files 包含元数据对象 chunks 包含其他一些相关信息的二进制块为了使多个 GridFS 命名为一个单一的数据库，文件和块都有一个前缀，默认情况下，前缀是 fs，所以任何默认的 GridFS 存储将包括命名空间 fs.files 和 fs.chunks。各种第三方语言的驱动有权限改变这个前缀，所以你可以尝试设置另一个 GridFS 命名空间用于存储照片，它的具体位置为:photos.files 和 photos.chunks。 可以用 mongofiles 工具进行操作：123456[root@localhost bin]# mongofiles put testfile #插入文件[root@localhost bin]# mongofiles list #可以查看库里有哪些 GridFS&gt; show collections #可以看到库里多了fs.files和fs.chunks两张表&gt; db.fs.files.find(); &gt; db.fs.chunks.find(); #file跟chunk是一对多的关系,file里面只是存储文件名之类的描述信息,然后分成多个chunk存储[root@localhost bin]# mongofiles get testfile #获取文件 MapReduce类似于MySql中的”group by”1234567891011121314db.runCommand( &#123; mapreduce : &lt;collection&gt;, #要操作的目标集合 map : &lt;mapfunction&gt;, #映射函数 (生成键值对序列，作为 reduce 函数参数)。 reduce : &lt;reducefunction&gt; #统计函数 [, query : &lt;query filter object&gt;] #目标记录过滤 [, sort : &lt;sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces&gt;] #目标记录排序。 [, limit : &lt;number of objects to return from collection&gt;] #限制目标记录数量 [, out : &lt;see output options below&gt;] #统计结果存放集合 (不指定则使用临时集合，在客户端断开后自动删除)。 [, keeptemp: &lt;true|false&gt;] #是否保留临时集合 [, finalize : &lt;finalizefunction&gt;] #最终处理函数 (对 reduce 返回结果进行最终整理后存入结果集合)。 [, scope : &lt;object where fields go into javascript global scope &gt;] #向 map、reduce、finalize 导入外部变量。 [, verbose : true] #显示详细的时间统计信息。 &#125; ); 示例：12345678910111213141516171819202122232425262728293031323334353637&gt; db.students.insert(&#123;classid:1, age:14, name:'Tom'&#125;) &gt; db.students.insert(&#123;classid:1, age:12, name:'Jacky'&#125;) &gt; db.students.insert(&#123;classid:2, age:16, name:'Lily'&#125;) &gt; db.students.insert(&#123;classid:2, age:9, name:'Tony'&#125;) &gt; db.students.insert(&#123;classid:2, age:19, name:'Harry'&#125;) &gt; db.students.insert(&#123;classid:2, age:13, name:'Vincent'&#125;) &gt; db.students.insert(&#123;classid:1, age:14, name:'Bill'&#125;) &gt; db.students.insert(&#123;classid:2, age:17, name:'Bruce'&#125;) &gt; &gt; m = function() &#123; emit(this.classid, 1) &#125; #emit(this.classid, &#123;count:1&#125;) 亦可#将 Map 返回的键值序列组合成 &#123; key, [value1, value2, value3, value...] &#125; 传递给 reduce。&gt; r = function(key, values) &#123; ... var x = 0; ... values.forEach(function(v) &#123; x += v &#125;); ... return x; ... &#125; &gt; f = function(key, value) &#123; return &#123;classid:key, count:value&#125;; &#125; &gt; res = db.runCommand(&#123; ... mapreduce:\"students\", ... map:m, ... reduce:r, ... out:\"students_res\", ... finalize:f... &#125;); &gt; db.students_res.find() &#123; \"_id\" : 1, \"value\" : &#123; \"classid\" : 1, \"count\" : 3 &#125; &#125; &#123; \"_id\" : 2, \"value\" : &#123; \"classid\" : 2, \"count\" : 5 &#125; &#125; &gt; res = db.runCommand(&#123; ... mapreduce:\"students\", ... map:m, ... reduce:r, ... out:\"students_res\", ... finalize:f, ... query:&#123;age:&#123;$lt:10&#125;&#125; #只取 age&lt;10 的数据，然后再进行统计... &#125;);&gt; db.students_res.find(); &#123; \"_id\" : 2, \"value\" : &#123; \"classid\" : 2, \"count\" : 1 &#125; &#125; 上面最后一个查询的操作等同于select _id,classid,count(classid) as count, from students where age&lt;10 group by classid 数据导出和导入导出：[root@localhost bin]# mongoexport -d my_mongodb -c user -o user.dat参数说明:-d 指明使用的库, 本例中为” my_mongodb”-c 指明要导出的表, 本例中为”user”-o 指明要导出的文件名, 本例中为”user.dat”[root@localhost bin]# mongoexport -d my_mongodb -c user –csv -f uid,username,age -o user_csv.dat-csv 指要要导出为 csv 格式-f 指明需要导出哪些例 导入：(如果数据库中表不存在，会根据导入的数据结构自动建立)12345[root@localhost bin]# mongoimport -d my_mongodb -c user user.dat [root@localhost bin]# mongoimport -d my_mongodb -c user --type csv --headerline --file user_csv.dat -type 指明要导入的文件格式 -headerline 批明不导入第一行，因为第一行是列名 -file 指明要导入的文件路径 数据备份和恢复 备份:此时会在当前目录下创建一个 dump 目录，用于存放备份出来的文件，也可以指定备份存放的目录， 12[root@localhost bin]# mongodump -d my_mongodb [root@localhost bin]# mongodump -d my_mongodb -o my_mongodb_dump 恢复:[root@localhost bin]# mongorestore -d my_mongodb my_mongodb_dump/* 访问控制可以写到配置文件中绑定 IP 内网地址访问 MongoDB 服务:[root@localhost bin]# mongod --bind_ip 192.168.1.103客户端访问时需要明确指定服务端的 IP，否则会报错 设置监听端口:[root@localhost bin]# mongod --bind_ip 192.168.1.103 --port 28018客户端访问时需要明确指定服务端的 IP和port，否则会报错，要这样访问 mongo 192.168.1.102:28018 使用用户名和口令登录:[root@localhost bin]# mongod --auth ★这里用户名口令的验证,直到你在 admin.system.users 中添加了用户才有效.123&gt; db.addUser(\"root\",\"111\") &gt; db.auth(\"root\",\"111\") #验证用户是否添加成功，正确会返回1[root@localhost bin]# mongo -u root -111 为test库设一个只读的用户:123&gt; use test&gt; db.addUser(\"user_reader\", \"user_pwd\", true) [root@localhost bin]# mongo -u user_reader -user_pwd 命令行操作MongoDB shell 不仅仅是一个交互式的 shell，它也支持执行指定 javascript 文件，也支持执行指定的命令片断123[root@localhost bin]# mongo test --eval \"printjson(db.t1.count())\" [root@localhost bin]# mongo --quiet t1_count.js ★--quiet 可以将一些登录信息屏蔽掉，这样可以让结果更清晰。 进程控制查看活动进程:&gt; db.currentOp();结束进程:&gt; db.killOp(1234/*opid*/)★不要 kill 内部发起的操作，比如说 replica set 发起的 sync 操作等 性能篇创建索引:{backgroud:true}可选&gt; db.t3.ensureIndex({age:1} , {backgroud:true}) 文档索引:索引可以任何类型的字段，甚至文档 123456&gt; db.factories.insert( &#123; name: \"wwl\", addr: &#123; city: \"Beijing\", state: \"BJ\" &#125; &#125; ); &gt; db.factories.ensureIndex( &#123; addr : 1 &#125; ); #在 addr 列上创建索引 //下面这个查询将会用到我们刚刚建立的索引 &gt; db.factories.find( &#123; addr: &#123; city: \"Beijing\", state: \"BJ\" &#125; &#125; ); //但是下面这个查询将不会用到索引，因为查询的顺序跟索引建立的顺序不一样 &gt; db.factories.find( &#123; addr: &#123; state: \"BJ\" , city: \"Beijing\"&#125; &#125; ); 组合索引:&gt; db.factories.ensureIndex( { &quot;addr.city&quot; : 1, &quot;addr.state&quot; : 1 } ); 唯一索引:&gt; db.factories.ensureIndex( { addr : 1 }{unique: true}); 面向文档的 NoSQL 数据库主要解决的问题不是高性能的并发读写，而是保证海量数据存储的同时，具有良好的查询性能。 MongoDB 在 bin 目录下提供了一系列有用的工具，这些工具提供了 MongoDB 在运维管理上的方便。 bsondump: 将 bson 格式的文件转储为 json 格式的数据 mongo: 客户端命令行工具，其实也是一个 js 解释器，支持 js 语法 mongod: 数据库服务端，每个实例启动一个进程，可以 fork 为后台运行 mongodump/ mongorestore: 数据库备份和恢复工具 mongoexport/ mongoimport: 数据导出和导入工具 mongofiles: GridFS 管理工具，可实现二制文件的存取 mongos: 分片路由，如果使用了 sharding 功能，则应用程序连接的是 mongos 而不是 mongosniff: 这一工具的作用类似于 tcpdump， 不同的是他只监控 MongoDB * 相关的包请求，并且是以指定的可读性的形式输出 mongostat: 实时性能监控工具 Python操作MongoDB连接数据库用pymongo直接连接12345from pymongo import MongoClientclient = MongoClient('192.168.40.87', 27037)db_name = 'TCL_Useraction'db = client[db_name]collection_useraction = db['useraction'] 这里是通过字典的方式访问数据库和集合，同时你也可以通过.（点号）的方式访问 用mongoengine连接1234567# 连接单mongofrom mongoengine import connectcon = connect(\"xcloud\", host=\"172.16.60.18:10001\")# 连接集群from pymongo import ReadPreferencecon = connect('xcloud', host='mongodb://172.16.60.18:10000,172.16.60.18:10001/xcloud?replicaSet=setA&amp;connectTimeoutMS=10000', read_preference=ReadPreference.SECONDARY_PREFERRED) – 读写分离（Read Preference）的几种模式 primary主节点，默认模式，读操作只在主节点，如果主节点不可用，报错或者抛出异常。 primaryPreferred首选主节点，大多情况下读操作在主节点，如果主节点不可用，如故障转移，读操作在从节点。 secondary从节点，读操作只在从节点， 如果从节点不可用，报错或者抛出异常。 secondaryPreferred首选从节点，大多情况下读操作在从节点，特殊情况（如单主节点架构）读操作在主节点。 nearest最邻近节点，读操作在最邻近的成员，可能是主节点或者从节点 增删改查1234567891011121314151617181920212223242526272829&gt;&gt;&gt; import pymongo&gt;&gt;&gt; from pymongo import Connection &gt;&gt;&gt; con = Connection()&gt;&gt;&gt; db = con.test &gt;&gt;&gt; posts = db.post &gt;&gt;&gt; posts.insert(&#123;\"title\":\"Python and MongoDB\",\"author\":\"SErHo\",\"slug\":\"python-mongodb\"&#125;) &gt;&gt;&gt; count = posts.count()&gt;&gt;&gt; for post in posts.find(): print post&gt;&gt;&gt; post = posts.find_one(&#123;\"slug\":\"python-mongodb\"&#125;)&gt;&gt;&gt; post[\"slug\"] = \"haha\"&gt;&gt;&gt; posts.update(&#123;_id:post[\"_id\"]&#125;,post) #这里适合大幅度修改,另外post[\"_id\"]不能少,不然匹配出多个元素,则无法修改.&gt;&gt;&gt; posts.update(&#123;\"_id\":post[\"_id\"]&#125;,&#123;\"$set\":&#123;\"content\":\"Test Update SET....\"&#125;&#125;)#如果只更新一个键呢，那就不用这么大费周折了，可以使用”$set”这个修改器&gt;&gt;&gt; s = db.students.update(&#123;\"age\":55&#125;,&#123;\"$unset\":&#123;\"ddd\":\"\"&#125;&#125;)#删除某个键值，可以使用”$unset”&gt;&gt;&gt; posts.update(&#123;\"_id\":post[\"_id\"]&#125;,&#123;\"$inc\": &#123;\"views\":1&#125;&#125;)#访问量，每访问一次加1，可以用”$inc”，这个可以用来增加已有键的值，如果没有，则创建它（此字段只能是int型的）&gt;&gt;&gt; posts.update(&#123;\"_id\":post[\"_id\"]&#125;,&#123;\"$push\":&#123;\"tags\":\"Test\"&#125;&#125;)#向数组末尾添加元素，用\"$push\"&gt;&gt;&gt; posts.update(&#123;\"_id\":post[\"_id\"]&#125;,&#123;\"$addToSet\":&#123;\"tags\":&#123;\"$each\":[\"Python\",\"Django\"]&#125;&#125;&#125;) #为了避免加入了重复的，可以将\"$push\"改为使用\"$addToSet\"，如果需要添加多个值，可以配合\"$each\"来使用&gt;&gt;&gt; posts.update(&#123;\"_id\":post[\"_id\"]&#125;,&#123;\"$pop\":&#123;\"tags\":1&#125;&#125;)#\"$pop\"删除tags数组最后一个，如果是删除第一个，把1改为-1即可s = db.students.update(&#123;\"age\":55&#125;,&#123;\"$pull\":&#123;\"tags\":&#123;\"$lt\":3&#125;&#125;&#125;)#可以使用”$pull”来删除数组中指定的值，它会删除数组中所有匹配的值&gt;&gt;&gt; posts.update(&#123;\"tags\":\"MongoDB\"&#125;,&#123;\"$set\":&#123;\"tags.$\":\"Hello\"&#125;&#125;)#先搜索tags中满足”MongoDB”的，如果找到，就把它修改为”Hello” 同步参考：http://snowolf.iteye.com/blog/1974747http://heylinux.com/archives/1973.htmlhttp://www.server110.com/mongodb/201403/8342.html 主从复制一般数据库都会用到这种最通用的模式——主从模式。这种方式简单灵活，可用于备份、故障恢复，读扩展。为了平衡负载，一般通过读写分离模式，即主库写、从库读。 假设我们有两台MongoDB服务器，10.11.20.140和10.11.20.139。如果要配置主从复制，可参考如下实现：Master（10.11.20.140）：12345678port = 27017dbpath = /data/dblogpath = /var/log/mongodb.loglogappend = true journal = truepidfile = /var/run/mongodb.pidfork = truemaster = true 注意：master=true Slave（10.11.20.139）：12345678port=27017dbpath = /data/dblogpath = /var/log/mongodb.loglogappend = true journal = truefork = trueslave = truesource = 10.11.20.140:27017 注意：slave=truesource=10.11.20.140:27017 如果这是配置了“auth = false”，主从同步可能失败。 集群复制主从复制虽然可以承受一定的负载压力，但这种方式仍然是一个单点，如果主库挂了，数据写入就成了风险。如果，当主库挂掉的时候，可以在访问ip不变的前提下，自动将从库作为主库使用，是不是就能避免这种风险？貌似这又涉及到Linux上的服务KeepAlive等等。 在Mongodb中，提供了一种优于主从模式的集群复制（ReplicateSet）。最理想的模式是，节点之间不分特定的主从。任何一个节点都可以是主节点primary，而其他节点都是secondary，甚至可以通过投票方式选出主节点。一般的集群复制，可以是如下这个结构： 确保主服务器上有数据，从服务器无数据，如果有则通过 use dbname和db.dropDatabase()将数据删除。 两台机器的Mongo集群– 新建mongo相关目录12345678910mkdir -p /data/a/r0 mkdir -p /data/a/r1 mkdir -p /data/b/r0 mkdir -p /data/b/r1 mkdir -p /data/logs/a mkdir -p /data/logs/b mkdir -p /data/configServer/r0 mkdir -p /data/configServer/r1 mkdir -p /data/logs/configServer mkdir -p /data/logs/serverlogs – 启动mongo12/usr/bin/mongod --logpath /data/logs/a/r0.log --logappend --dbpath /data/a/r0 --bind_ip 0.0.0.0 --port 10000 --shardsvr --replSet setA --rest --oplogSize 64 --directoryperdb --fork /usr/bin/mongod --logpath /data/logs/a/r1.log --logappend --dbpath /data/a/r1 --bind_ip 0.0.0.0 --port 10001 --shardsvr --replSet setA --rest --oplogSize 64 --directoryperdb --fork 无密码，bind_ip设置为0.0.0.0，其它机器才可访问 – 初始化复制集setA123/usr/bin/mongo 127.0.0.1:10000/admin config=&#123;_id: 'setA', members:[&#123;_id: 0,host:'127.0.0.1:10000'&#125;,&#123;_id:1,host:'127.0.0.1:10001'&#125;]&#125; rs.initiate(config); – 在secondary上初始化从状态12/usr/bin/mongo 127.0.0.1:10001rs.slaveOk() – 查看当前状态 rs.status() 三台机器的Mongo集群如果只有2台Mongodb，配置复制集群还不够安全，需要1个外在角色调整各个节点的角色。 这些节点包括： statndard 常规节点，存储一份完整的数据副本，参与投票，可以成为活跃节点，即primary节点 passive 只做存储，参与投票 arbiter 仲裁者只投票，不复制数据，也不能成为活跃节点当Primary宕掉后，可以通过Arbiter在Secodarys中选举一个Primary节点，避免单点故障 现在，我们可以增加一个仲裁节点，只负责仲裁，不做数据存储。12PRIMARY&gt; rs.addArb(\"127.0.0.1:10002\")&#123; \"ok\" : 1 &#125; 错误笔记 mongo - couldn’t connect to server 127.0.0.1:27017 第一步删除.lock文件， sudo rm /var/lib/mongodb/mongod.lock 第二步repair mongodb mongod --dbpath=/var/lib/mongodb -repair 第三步重启服务 sudo service mongodb start 何时选择 mongodb 你期望一个更高的写负载默认情况下，对比事务安全，MongoDB更关注高的插入速度。如果你需要加载大量低价值的业务数据，那么MongoDB将很适合你的用例。但是必须避免在要求高事务安全的情景下使用MongoDB，比如一个1000万美元的交易。 不可靠环境保证高可用性设置副本集（主-从服务器设置）不仅方便而且很快，此外，使用MongoDB还可以快速、安全及自动化的实现节点（或数据中心）故障转移。 未来会有一个很大的规模数据库扩展是非常有挑战性的，当单表格大小达到5-10GB时，MySQL表格性能会毫无疑问的降低。如果你需要分片并且分割你的数据库，MongoDB将很容易实现这一点。 使用基于位置的数据查询MongoDB支持二维空间索引，因此可以快速及精确的从指定位置获取数据。 非结构化数据的爆发增长给RDBMS增加列在有些情况下可能锁定整个数据库，或者增加负载从而导致性能下降，这个问题通常发生在表格大于1GB（更是下文提到BillRun系统中的痛点——单表格动辄几GB）的情况下。鉴于MongoDB的弱数据结构模式，添加1个新字段不会对旧表格有任何影响，整个过程会非常快速；因此，在应用程序发生改变时，你不需要专门的1个DBA去修改数据库模式。 缺少专业的数据库管理员如果你没有专业的DBA，同时你也不需要结构化你的数据及做join查询，MongoDB将会是你的首选。MongoDB非常适合类的持久化，类可以被序列化成JSON并储存在MongoDB。需要注意的是，如果期望获得一个更大的规模，你必须要了解一些最佳实践来避免走入误区。 面试问题MongoDB 是目前最好的面向文档的免费开源NoSQL数据库。如果你正准备参加MongoDB NoSQL数据库的技术面试，你最好看看下面的MongoDB NoSQL面试问答。这些MongoDB NoSQL面试问答涵盖了NoSQL数据库基本的概念，复制(Replication)，分片(Sharding)，事务和锁，跟踪分析工具 (Profiler)，Nuances和日志等特性。让我们看看下面的这些MongoDB NoSQL数据库的面试问答吧： 你说的NoSQL数据库是什么意思？NoSQL与RDBMS直接有什么区别？为什么要使用和不使用NoSQL数据库？说一说NoSQL数据库的几个优点？我写了一篇完整的博客来回答这些问题，看这里 NoSQL数据库有哪些类型？NoSQL数据库的类型例如：MongoDB, Cassandra, CouchDB, Hypertable, Redis, Riak, Neo4j, HBASE, Couchbase, MemcacheDB, RevenDB and Voldemort are the examples of NoSQL databases. 详细阅读。 MySQL与MongoDB之间最基本的差别是什么？MySQL 和MongoDB两者都是免费开源的数据库。MySQL和MongoDB有许多基本差别包括数据的表示(data representation)，查询，关系，事务，schema的设计和定义，标准化(normalization)，速度和性能。通过比较MySQL 和MongoDB，实际上我们是在比较关系型和非关系型数据库。详细阅读 你怎么比较MongoDB、CouchDB及CouchBase?MongoDB和CouchDB都是面向文档的数据库。MongoDB和CouchDB都是开源NoSQL数据库的最典型代表。 除了都以文档形式存储外它们没有其他的共同点。MongoDB和CouchDB在数据模型实现、接口、对象存储以及复制方法等方面有很多不同。细节可以参见下面的链接：MongDB vs CouchDBCouchDB vs CouchBase MongoDB成为最好NoSQL数据库的原因是什么?以下特点使得MongoDB成为最好的NoSQL数据库： 面向文件的 高性能 高可用性 易扩展性 丰富的查询语言 32位系统上有什么细微差别?journaling会激活额外的内存映射文件。这将进一步抑制32位版本上的数据库大小。因此，现在journaling在32位系统上默认是禁用的。 journal回放在条目(entry)不完整时(比如恰巧有一个中途故障了)会遇到问题吗？每个journal (group)的写操作都是一致的，除非它是完整的否则在恢复过程中它不会回放。 分析器在MongoDB中的作用是什么?MongoDB中包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询（或写操作）；利用这一信息，比如，可以确定是否需要添加索引。 名字空间（namespace）是什么？MongoDB存储BSON对象在丛集（collection）中。数据库名字和丛集名字以句点连结起来叫做名字空间（namespace）。 如果用户移除对象的属性，该属性是否从存储层中删除？是的，用户移除属性然后对象会重新保存（re-save()）。 能否使用日志特征进行安全备份？是的。 允许空值null吗？对于对象成员而言，是的。然而用户不能够添加空值（null）到数据库丛集（collection）因为空值不是对象。然而用户能够添加空对象{}。 更新操作立刻fsync到磁盘？不会，磁盘写操作默认是延迟执行的。写操作可能在两三秒（默认在60秒内）后到达磁盘。例如，如果一秒内数据库收到一千个对一个对象递增的操作，仅刷新磁盘一次。（注意，尽管fsync选项在命令行和经过getLastError_old是有效的）（译者：也许是坑人的面试题？？）。 如何执行事务/加锁？MongoDB没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成MySQL MylSAM的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里。 为什么我的数据文件如此庞大？MongoDB会积极的预分配预留空间来防止文件系统碎片。 启用备份故障恢复需要多久？从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间。这期间在主数据库上的操作将会失败–包括写入和强一致性读取 (strong consistent read)操作。然而，你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveOk模式下)，即使在这段时间里。 什么是master或primary？它是当前备份集群(replica set)中负责处理所有写入操作的主要节点/成员。在一个备份集群中，当失效备援(failover)事件发生时，一个另外的成员会变成primary。 什么是secondary或slave？Seconday从当前的primary上复制相应的操作。它是通过跟踪复制oplog(local.oplog.rs)做到的。 我必须调用getLastError来确保写操作生效了么？不用。不管你有没有调用getLastError(又叫”Safe Mode”)服务器做的操作都一样。调用getLastError只是为了确认写操作成功提交了。当然，你经常想得到确认，但是写操作的安全性和是否生效不是由这个决定的。 Should I start out with sharded or with a non-sharded MongoDB environment? 我应该启动一个集群分片（sharded）还是一个非集群分片的 MongoDB 环境？为开发便捷起见，我们建议以非集群分片（unsharded）方式开始一个 MongoDB 环境，除非一台服务器不足以存放你的初始数据集。从非集群分片升级到集群分片（sharding）是无缝的，所以在你的数据集还不是很大的时候没必要考虑集群分片（sharding）。 分片（sharding）和复制（replication）是怎样工作的？每一个分片（shard）是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片（shard）使用集群。 数据在什么时候才会扩展到多个分片（shard）里？MongoDB 分片是基于区域（range）的。所以一个集合（collection）中的所有的对象都被存放到一个块（chunk）中。只有当存在多余一个块的时候，才会有多个分片获取数据的选项（Only when there is more than 1 chunk is there an option for multiple shards to get data.）。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移。 当我试图更新一个正在被迁移的块（chunk）上的文档时会发生什么？更新操作会立即发生在旧的分片（shard）上，然后更改才会在所有权转移（ownership transfers）前复制到新的分片上。 如果在一个分片（shard）停止或者很慢的时候，我发起一个查询会怎样？如果一个分片（shard）停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片（shard）响应很慢，MongoDB则会等待它的响应。 我可以把moveChunk目录里的旧文件删除吗？没问题，这些文件是在分片（shard）进行均衡操作（balancing）的时候产生的临时文件。一旦这些操作已经完成，相关的临时文件也应该被删除掉。但目前清理工作是需要手动的，所以请小心地考虑再释放这些文件的空间。 我怎么查看 Mongo 正在使用的链接？db._adminCommand(“connPoolStats”); 如果块移动操作（moveChunk）失败了，我需要手动清除部分转移的文档吗？不需要，移动操作是一致（consistent）并且是确定性的（deterministic）；一次失败后，移动操作会不断重试；当完成后，数据只会出现在新的分片里（shard）。 如果我在使用复制技术（replication），可以一部分使用日志（journaling）而其他部分则不使用吗？可以。 mongodb设置远程连接 添加管理员账号mongo 进入控制台，做如下操作 123use adminswitched to db admindb.addUser('tank','test'); 配置mongodb.conf 12bind_ip = 127.0.0.1 //注释此行auth = true //将此行前的注释去掉 重启mongodb 1/etc/init.d/mongod 防火墙开放27017端口 1iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 27017 -j ACCEPT mongdb 远程连接 一图胜千言 参考 http://www.cnblogs.com/cswuyg/p/4595799.html","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://woshijingshenbing.com/tags/MongoDB/"}]},{"title":"大话设计模式","date":"2016-12-11T16:00:00.000Z","path":"2016/12/12/大话设计模式/","text":"概述前段时间面试，被问到面向对象编程的好处，我脑子一下子短路了三秒钟，因为觉得这个问题太简单，感觉有诈，但仍是本能的回答了下去：1“面向对象的三大原则是封装、继承、多态，好处就是代码写得少，便于理解，以及易于修改。我们可以把对象们的共同属性和行为封装到类中，如果有子对象有额外的操作，可以定义子类进行继承，而不用再写一遍父类中的代码，多态可以实现对子类的抽象，对客户只暴露父类中方法，具体的实现在子类中完成，这样修改子类，或替换子类，对客户的影响都不大，就是所谓的易于修改，或者称为松耦合。” 再深入一些，就讲不出来了。然后又被问用到过哪些设计模式，自己好像只回答了一个装饰器模式，其他的一下子也说不出来，因为平时用python比较多，会经常写装饰器，所以这个印象比较深刻。工作过程中肯定也潜移默化的用到了不少设计模式，但一直没有总结过。 面试回来赶紧补了下课，才发现自己这方面知识有多薄弱，因为python标榜的是面向函数编程，所以自己经常会在一个module里写很多函数进行调用，类倒是用得越来越少，面向对象的好处，都快被自己忽略掉了。看同事们的代码，也是大把大把面向过程编程，到处是小函数，一个功能会被不同的人，写在不同的地方，代码实在太难以维护。 在网上看了几篇帖子，都是专业术语，比较晦涩，好像懂了，但仍是不太明了。于是在kindle中下载了两本书，一本《大话设计模式》，用诙谐的语句，浅显易懂的说明了设计模式怎么用，用在哪里，一周就看完了；另一本《设计模式导论》，更深入的介绍了各种设计模式的异同，和更多的应用场景，相似的设计模式之间如何取舍，尚未看完，边看边思考，而且这个过程，可以拿我们现在项目（代码超15w行）开刀，修改的地方，以及为什么这么修改，会陆续记录在这篇博客中，供大家参考。 五大原则（SOLID）原则一：单一责任原则（Single Responsibility Principle） 如果一个类（或方法、或服务）有超过一个理由让它修改代码（或者有超过一个功能），你就要根据它的功能把它拆分开 原则二：开闭原则（Open-Closed Principle） 扩展一项功能的时候，模块原有的核心类的源代码不应该改变 示例： 如果浏览器是跟一个具体的服务器（例如IIS）紧耦合的，那要是把IIS换成Apache，浏览器跟服务器交互的部分就肯定得改了。这牵一发而动全身的改动太恶心了。我们定义一个抽象服务类，对修改关闭（有事没事都别改它的代码），具体类的实现却是对扩展开放的。 原则三：里氏替换原则（Liskov’s Substitution Principle） 基类的函数在子类里面也必须正常使用，类图设计完的时候必须用LSP原则作为验证工具来检验你写的继承关系是不是合适，否则继承会发生混乱。 定义鸭子基类不用充电，如果实例化的鸭子要充电，则这个鸭子不是要的鸭子。 示例：如果在鸟基类中定义了飞的动作，那么KingFisher（翠鸟）继承这个基类没有问题，但Ostrich（鸵鸟）继承就不合适了，就算它属于鸟类，也应该继承另外一个基类，因为它不能飞。 原则四：接口隔离原则（The Interface Segregation Principle） 客户端代码不应该费劲去弄懂他用不到的接口，服务端接口应该只暴露给客户端它需要用到的功能。接口分离原则告诉你要让接口简单，只做它必须做的事，这样才易懂易重用。 好比你想买一台电视机，有两种可选的。一种是有很多开关和按钮，大多数开关都不知道是干嘛的，也不知道有用没用。另一种只有几个开关和按钮，看起来又熟悉又容易理解。如果这两台电视功能一样，你选哪个？ 原则五：依赖倒置原则（The Dependency Inversion Principle） 高层模块不应该依赖于低层模块。两者都应该依赖于抽象。核心是可插拔。 车子不是直接依赖引擎和轮子的，而是他们的抽象说明。然后任何满足这个抽象的引擎和轮子都能够组装到车子上了。 如果违背，调用底层类的高层代码被推倒重来，底层代码修改时，不得不大量修改高层代码。 其它原则 组合优于继承：尽量组合，这比继承好。 傻瓜原则：你的类知道的东西越少越好。 闭包原则：把相关的类打包到一起。 稳定抽象原则：想少改动一个类的话，就尽量用抽象的东西定义它。 经典的23种模式 创建型模式(5)简单工厂模式抽象工厂模式单例模式原型模式建造者模式结构型模式(7)桥梁模式代理模式外观模式装饰模式适配器模式组合模式享元模式行为型模式(11)策略模式模板方法模式观察者模式迭代器模式职责链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式思维导图参考网站： 《大话设计模式》Python版代码实现 设计模式详解 设计模式六大原则 书籍： 《大话设计模式》 《设计模式导论》","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://woshijingshenbing.com/tags/设计模式/"}]},{"title":"VIM 随记","date":"2016-10-16T13:58:39.000Z","path":"2016/10/16/VIM-随记/","text":"多行注释列注释 多行注释： 按下Ctrl + v，进入列模式; 在行首选择需要注释的行; 按下“I”，进入插入模式； 然后输入注释符（“//”、“#”等）; 按下“Esc”键。 删除多行注释： 按下Ctrl + v, 进入列模式; 选定要取消的注释符; 按下“x”或者“d”. 其他选择方式在正常模式下（按ESC进入）按键v进入可视化模式，然后按键盘左右键或h,l键即可实现文本的选择。其它相关命令： v：按字符选择。经常使用的模式，所以亲自尝试一下它。 V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。 CTRL＋v：按块选择。非常强大，只在很少的编辑器中才有这样的功能。你可以选择一个矩形块，并且在这个矩形里面的文本会被高亮。 值得注意的是如果VIM中使用自动换行，那么直到你按ENTER换行前，VIM都会将你之前输入的内容视为一行而不是你看到的好几行，按块选择时就会按VIM中的行来选择块。 在选择模式的时候使用上面所述的方向键和命令（motion）。比如，vwww，会高亮光标前面的三个词。Vjj 将会高亮当前行以及下面两行。 快捷键一般模式： 移动光标 h(左), j(下), k(上), l(右) [Ctrl] + [f]：屏幕『向前』移动一页（常用） [Ctrl] + [b]：屏幕『向后』(向下)移动一页（常用） [Ctrl] + [d]：屏幕『向前』移动半页 [Ctrl] + [u]：屏幕『向后』移动半页 数字 + 空格：按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0：这是数字『 0 』：移动到这一行的最前面字符处（常用） $：移动到这一行的最后面字符处（常用） H：光标移动到这个屏幕的最上方那一行 M：光标移动到这个屏幕的中央那一行 L：光标移动到这个屏幕的最下方那一行 G：移动到这个档案的最后一行（常用） nG：移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的 20 行(可配合 :set nu) 一般模式： 搜寻与取代 /word：向光标之后寻找一个字符串名称为 word 的字符串。（常用） ?word：向光标之前寻找一个字符串名称为 word 的字符串。 :n1,n2s/word1/word2/g – 在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！（常用） :1,$s/word1/word2/g – 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！（常用） :1,$s/word1/word2/gc – 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给使用者确认（conform）是否需要取代！（常用） 一般模式：删除、复制与贴上 x 为向后删除一个字符， X 为向前删除一个字符（常用） nx 向后删除 n 个字符 dd 删除游标所在的那一整列（常用） ndd 删除光标所在的向下 n 列，例如 20dd 则是删除 20 列（常用） d1G 删除游标所在到第一行的所有数据 dG 删除游标所在到最后一行的所有数据 dw 删除当前字符到单词尾包括空格的所有字符，相当于前切一个单词 复制跟删除类似，只是将d改成y即可 p 为复制的数据在光标下一行贴上，P 则为贴在游标上一行！（常用） J 将光标所在列与下一列的数据结合成同一列 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。（常用） Ctrl+R可以恢复对使用u命令的操作 进入编辑模式 i：在目前的光标所在处插入输入之文字，已存在的文字会向后退；（常用） I：在当前行首处插入光标开始输入； a：由目前光标所在的下一个字开始输入，已存在的文字会向后退：（常用） A：在当前行尾处插入光标开始输入； o, O：插入新的一行：从光标所在的下（上）一行枝行首开始输入文字；（常用） r, R：r 会取代光标所在的那一个字符；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用） Esc 退出编辑模式，回到一般模式中（常用） 指令列命令模式 :w 将编辑的数据写入硬盘档案中（常用） :w! 若档案属性为『只读』时，强制写入该档案 :q 离开 vi （常用） :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 :wq 储存后离开，若为 :wq! 则为强制储存后离开（常用） :e! 将档案还原到最原始的状态！ ZZ 若档案没有更动，则不储存离开，若档案已经经过更动，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』这个档案内容加到游标所在行后面 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令列模式下执行 command 的显示结果！例如[ :! ls /home ] 插件vundle 插件管理器 下载 vundle$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 在.vimrc中添加bundle的配置 12345678910111213141516171819202122232425262728293031323334353637set nocompatible \" be iMprovedfiletype off \" required!set rtp+=~/.vim/bundle/vundle/call vundle#rc()\" let Vundle manage VundleBundle 'gmarik/vundle'\"my Bundle here:\"\" original repos on githubBundle 'kien/ctrlp.vim'Bundle 'sukima/xmledit'Bundle 'sjl/gundo.vim'Bundle 'jiangmiao/auto-pairs'Bundle 'klen/python-mode'Bundle 'Valloric/ListToggle'Bundle 'SirVer/ultisnips'Bundle 'Valloric/YouCompleteMe'Bundle 'scrooloose/syntastic'Bundle 't9md/vim-quickhl'\" Bundle 'Lokaltog/vim-powerline'Bundle 'scrooloose/nerdcommenter'\"..................................\" vim-scripts reposBundle 'YankRing.vim'Bundle 'vcscommand.vim'Bundle 'ShowPairs'Bundle 'SudoEdit.vim'Bundle 'EasyGrep'Bundle 'VOoM'Bundle 'VimIM'\"..................................\" non github repos\" Bundle 'git://git.wincent.com/command-t.git'\"......................................filetype plugin indent on bundle分为三类： * 在Github vim-scripts 用户下的repos,只需要写出repos名称 * 在Github其他用户下的repos, 需要写出”用户名/repos名” * 不在Github上的插件，需要写出git全路径 安装插件打开一个vim, 运行:BundleInstall，或者在命令行运行 vim +BundleInstall +qall，安装完成后插件就能用了。 常用命令 更新插件:BundleUpdate 清除不再使用的插件:BundleClean, 列出所有插件:BundleList 查找插件:BundleSearch YouCompleteMe 代码补全 下载 vundle$ git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/vundle 恢复文件vi在编辑某一个文件时，会生成一个临时文件，这个文件以 . 开头并以 .swp结尾。正常退出该文件自动删除，如果意外退出例如忽然断电，该文件不会删除，我们在下次编辑时可以选择一下命令处理： O只读打开，不改变文件内容 E继续编辑文件，不恢复.swp文件保存的内容 R将恢复上次编辑以后未保存文件内容, 或者使用vi －r 文件名来恢复未保存的内容 Q退出vi D删除.swp文件 其它操作 在同一编辑窗打开第二个文件，用:sp [filename] 在多个编辑文件之间切换，用Ctrl+w 命令前面加数字表示重复次数，加字母表示使用的缓冲区名称。 获取帮助，用:help [内容或命令] 设置 tab 为4个空格：在.vimrc中添加以下代码后，重启vim即可实现按TAB产生4个空格：12set ts=4 # 注：ts是tabstop的缩写，设TAB宽4个空格set expandtab 对于已保存的文件，可以使用下面的方法进行空格和TAB的替换：TAB替换为空格：123:set ts=4:set expandtab:%retab! 空格替换为TAB：123:set ts=4:set noexpandtab:%retab! 加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 一图胜千言","tags":[{"name":"VIM","slug":"VIM","permalink":"http://woshijingshenbing.com/tags/VIM/"}]},{"title":"Mysql 随记","date":"2016-10-16T13:52:32.000Z","path":"2016/10/16/Mysql-随记/","text":"概述不是详细mysql的技术 大全,只是平时工作中会用到,但又总记不住的一些操作,方便自己所取. 基本操作12345678910启动mysql服务:&gt;start mysql打开MySql交互界面：&gt;mysql -u root -p Enter password: 你的密码 create database blog default charset utf8use blogshow tablesselect * from book desc createtime 执行sql文件或脚本 1mysql -h localhost -uroot -p123456 -B auth_db &lt; F:\\hello world\\niuzi.sql -e'show tables' 导出数据 1mysqldump -ueclouduser -peclouduser123 auth_db auth_permission_info&gt;&gt;~/db_sql/auth_permission_info.sql 创建自定义函数在使用MySQL的过程中，mysql自带的函数可能不能完成我们的业务需求，这时就需要自定义函数,例如笔者在开发过程中遇到下面这个问题：mysql表结构如下123456789101112131415DROP TABLE IF EXISTS `test`; CREATE TABLE `test` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `pic` varchar(50) NOT NULL, `hashcode` varchar(16) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of test -- ---------------------------- INSERT INTO `test` VALUES ('1', '2012120910403250c3fa209bf48.jpg', 'bf8f83818080c0f1'); INSERT INTO `test` VALUES ('2', '2012120620430750c092db26557.JPG', 'ff9880f0f680ceff'); INSERT INTO `test` VALUES ('3', '2012120619582550c08861eb062.jpg', '7f7f004f7f7f7c7f'); INSERT INTO `test` VALUES ('4', '2012112911072650b6d16e7f21f.jpg', '7f7f004f7f7f007f'); 其中pic字段为图片名称，hashcode是图片的感知哈希编码（16进制编码字符串，长度固定16位），用户输入一个hashcode，怎么从数据库中找出满足字符串对应位置的字符不同的个数小于5的记录呢?就像“11001”和“11101”对应位置不同字符不同的个数为1，比如 用户输入”7f7f004f7f7f00af”,那么第三条和第四条记录是满足的，怎么实现呢？如果单纯的依靠mysql自带的函数很难完成，这时就需要建立自定义函数解决。建立自定义函数的过程如下： 进入mysql命令行mysql&gt; 用delimiter命令来把语句定界符从 ;变为//。这样就允许在程序体用;定界符传递到服务器，而不是被mysql自己来解释。mysql&gt; delimiter // 创建自定义函数 12345678910111213141516mysql&gt;CREATE FUNCTION hashDiff( s1 varchar(16), s2 varchar(16))-&gt;RETURNS INT-&gt;BEGIN-&gt;DECLARE diff, x INT;-&gt;SET diff =0;-&gt;SET x = 0;-&gt;WHILE (x &lt; 16 ) DO-&gt;SET x = x+1;-&gt;if SUBSTRING(s1, x,1)&lt;&gt;SUBSTRING(s2, x,1) then-&gt;set diff=diff+ 1;-&gt;end if;-&gt;END WHILE;-&gt;RETURN diff;-&gt;END-&gt;//mysql&gt;select * from test t where hashDiff(t.hashcode,'ff9880f0f680ceff') &lt; 5; 创建存储过程 进入mysql命令行mysql&gt; 用delimiter命令来把语句定界符从 ;变为//。这样就允许在程序体用;定界符传递到服务器，而不是被mysql自己来解释。mysql&gt; delimiter // 创建存储过程 1234567891011121314151617181920mysql&gt; delimiter //mysql&gt; CREATE PROCEDURE simpleproc (OUT param1 INT) -&gt; BEGIN -&gt; SELECT COUNT(*) INTO param1 FROM t; -&gt; END -&gt; //Query OK, 0 rows affected (0.00 sec) mysql&gt; delimiter ;mysql&gt; CALL simpleproc(@a);Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT @a;+------+| @a |+------+| 3 |+------+1 row in set (0.00 sec) MySQL的语句执行顺序MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。 下面我们来具体分析一下查询处理的每一个阶段 FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6. HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. ORDER BY: 将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10. LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。 Python操作MySql123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; import MySQLdb&gt;&gt;&gt; Con = MySQLdb.Connect(host=\"127.0.0.1\", port=3306, user=\"yourname\", passwd=\"yourpwd\", db=\"test\")&gt;&gt;&gt; Cur = Con.cursor() # 如果某个数据库支持事务，会自动开启&gt;&gt;&gt; sql = \"SELECT top 1 * FROM test.testing\"&gt;&gt;&gt; Cur.execute(sql)&gt;&gt;&gt; data = Cur.fetchone()&gt;&gt;&gt; Cur.execute(\"create table if not exists\\ writers(Id int primary key auto_increment,Name varchar(25))\") #创建了一个数据表 writer(id,name)&gt;&gt;&gt; Cur.execute(\"insert into writer(Name) values('Jack London')\")&gt;&gt;&gt; Cur.execute(\"insert into writer(Name) values('Honore de Balzac')\") &gt;&gt;&gt; Cur.execute(\"insert into writer(Name) values('Lion Feuchtwanger')\") #插入了3条数据&gt;&gt;&gt; Con.commit() #事务的特性：手动提交，出错自动回滚&gt;&gt;&gt; sql = \"SELECT * FROM test.writer\"&gt;&gt;&gt; Cur.execute(sql)&gt;&gt;&gt; rows = Cur.fetchall() #将结果集（多维数组）存入rows里面&gt;&gt;&gt; for row in rows: print row&gt;&gt;&gt; Cur.execute(sql)#如果结果集太大，一下子加载到内存中不合适，这时用下面的方法&gt;&gt;&gt; numrows = int(Cur.rowcount)&gt;&gt;&gt; for i in range(numrows): row = Cur.fetchone() print row[0], row[1] #如果这里想用键值访问，例如row[\"Id\"]、row[\"Name\"]，只需在获取cursor时使用如此形式：Cur = Con.cursor(MySQLdb.cursors.DictCursor)&gt;&gt;&gt; desc = Cur.description #获取连接对象的描述信息&gt;&gt;&gt; print \"%s %3s\" % (desc[0][0], desc[1][0]) #打印表头，就是字段名称&gt;&gt;&gt; #把图片用二进制存入 MYSQL&gt;&gt;&gt; Cur.execute(\"CREATE TABLE Images(Id INT PRIMARY KEY AUTO_INCREMENT, Data MEDIUMBLOB);\") #创建一张表，用于存放图片&gt;&gt;&gt; fin = open(\"../web.jpg\")&gt;&gt;&gt; img = fin.read()&gt;&gt;&gt; fin.close()&gt;&gt;&gt; Cur.execute(\"INSERT INTO Images SET Data='%s'\" % MySQLdb.escape_string(img)) #escape_string函数将插入数据库的字符串进行转义，这会指一些 SQL 注入的攻击 &gt;&gt;&gt; #从数据库中把图片读出来&gt;&gt;&gt; cursor.execute(\"SELECT Data FROM Images LIMIT 1\")&gt;&gt;&gt; fout = open(\"image.png\",\"wb\")&gt;&gt;&gt; fout.write(cursor.fetchone()[0])&gt;&gt;&gt; fout.close()&gt;&gt;&gt; Cur.close()&gt;&gt;&gt; Con.close()","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://woshijingshenbing.com/tags/Mysql/"}]},{"title":"Git 随记","date":"2016-10-16T13:46:40.000Z","path":"2016/10/16/Git-随记/","text":"基本操作123456789101112git config --global user.name “Your Name”git config --global user.email “you@example.com”git mkdir sanyangcd sanyang/git init ls -agit add . //给当前的这个项目制作一个快照snapshot（index file 索引）git commit //将快照里登记的内容永久写入git仓库，也就是开发者已经想好了要提交自己的开发成果了。git diff //这个命令只在git add之前使用有效。如果已经add了，那么此命令输出为空git diff –cached //这个命令在git add之后在git commit之前有效。git status //这个命令在git commit之前有效，表示都有哪些文件发生了改动git log (-p) //查看开发日志，加-p显示每个版本的代码区别所在 分支操作1234567git branch experimental //开启一个experimental分支git branch //列出所有分支git checkout experimental //切换到experimental分支，进行一系列开发工作git checkout master //切换到主分支git merge experimental //将分支合并到主干道(必须在主分支中进行)git branch -d experimental //删除experimental分支，在已合并后；如果要强制删除，无论是否合并，用-Dgit clone -b master2 sanyang@http://www.kernel.org/pub/scm/git/git.git // 用帐号 sanyang 从 http://www.kernel.org/pub/scm/git/git.git 去克隆 master2 分支 协同工作 合作伙伴bob希望改进我（sanyang）的工作成果,先克隆到他本地 1bob$ git clone /home/rocrocket/project myrepo //此命令用于克隆我的代码到bob自己的myrepo目录下 bob提交自己的改进成果到我的git仓库中，并口头告知我他已经完成了工作 1bob$ git commit -a //不用加任何参数，因为当初clone的时候，git已经记住了我(sanyang)的工作目录，它会直接找到我的目录来取。 如果很信任对方(bob)能力，直接合并对方提交过来的工作 1sanyang$ git pull /home/bob/myrepo master 不是很信任，先放到我主分支下的某一目录下，检查过后再合并 12345git fetch /home/bob/myrepo master:bobworks git whatchanged -p master..bobworks //用来查看bob都做了什么git checkout master //切换到master分区git pull . bobworks //如果我检查了bob的工作后很满意，就可以用pull来将bobworks分支合并到我的项目中了git branch -D bobworks //如果我检查了bob的工作后很不满意，就可以用-D来放弃这个分支就可以了 过了几天，bob如果想继续帮助我开发，他需要先同步一下我这几天的工作成果，如下操作 1git pull ———————–Tips——————-（1）git commit -a 这是一个偷懒的命令，相当于git add .; git commit;但无法提交新添加的文件（2）log和status等命令只能查看当前当前分支进行的工作（3）merge两个分支时，两个分支都需要commit过（4）git pull . 跟 git merge 功能是一样的，以后完全可以用git pull .来代替git merge（5）开发日志的格式：第一行概括信息，第二行空行，第三行详细信息。（6）gitk 图形化当前分支的信息 原理Git有三个工作区域，分别为：工作目录（Working Directory）、暂存区（Stage或Index）以及资源库（Repository或Git Directory）。下图是文件在这三个工作区域之间的关系： Git使用了SHA-1算法计算数据的校验和，并将该结果作为索引，而非文件名。 两种状态足以表达Git中的文件，即：未跟踪（Untracked）和已跟踪（Tracked）。而对于已跟踪状态，我又将其分为：未修改的（Unmodified），Modified（已修改的），暂存的（Staged）和已提交的（committed）。 git clone不需输入账号密码的方法 在~/下， touch创建文件 .git-credentials，在里面按“i”然后输入：https://{username}:{password}@github.com，比如 https://aoeddklj:1233ds@github.com 在终端下执行ame@zhenyun ~ $git config --global credential.helper store 可以看到~/.gitconfig文件，会多了一项：12[credential]helper = store 这个时候输入命令 git clone http://username@url 时不需要输入密码，即可完成代码的git. 本地多个key-ssh 第一步 配置用户名和邮箱 12git config --global user.name \"sanyang\"git config --global user.email \"871757525@qq.com\" 第二步 生成SSH-Key的同时指定保存的文件名 12ssh-keygen -t rsa -f ~/.ssh/id_rsa -C \"871757525@qq.com\"ssh-keygen -t rsa -f ~/.ssh/id_rsa.oschina -C \"871757525@qq.com\" 第三步 新增并配置config文件 1touch ~/.ssh/config 配置示例 1234567Host 121.42.58.246 IdentityFile ~/.ssh/id_rsa User \"sanyang\"Host gitlab.xiangcloud.com.cn IdentityFile ~/.ssh/id_rsa.oschina User \"sanyang\" Git服务器搭建在Ubuntu上搭建Git服务器，我们使用VMware虚拟机安装两台Ubantu系统，分别命名为gitServer和gitClient_01 服务器(gitServer)上的操作 12345sudo apt-get install openssh-server # 安装SSH服务ps –e|grep ssh # 查看ssh服务是否启动sudo adduser git # 添加git用户sudo apt-get install git-core # 安装gitgit --bare init /home/git/myRep.git # 初始化仓库 客户端(gitClient_01)的操作 1git clone git@gitServer:/home/git/myRep.git # gitServer为服务器的ip或域名 使用docker部署gitlab应用http://www.jianshu.com/p/05e3bb375f64 git config 更改git默认编辑器为vim: git config --global core.editor vim 错误处理 错误1： server certificate verification failed. CAfile: /etc/ssl/certs/ca-certificates.crt CRLfile: none解决方案：执行 export GIT_SSL_NO_VERIFY=1 git与svn的区别 1) 最核心的区别Git是分布式的，而Svn不是分布的。能理解这点，上手会很容易，声明一点Git并不是目前唯一的分布式版本控制系统，还有比如Mercurial等，所以说它们差不许多。话说回来Git跟Svn一样有自己的集中式版本库和Server端，但Git更倾向于分布式开发，因为每一个开发人员的电脑上都有一个Local Repository,所以即使没有网络也一样可以Commit，查看历史版本记录，创建项 目分支等操作，等网络再次连接上Push到Server端。 从上面看GIt真的很棒，但是GIt adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。 2)Git把内容按元数据方式存储，而SVN是按文件：因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。.git目录的体积大小跟.svn比较，你会发现它们差距很大。 3) Git没有一个全局版本号，而SVN有：目前为止这是跟SVN相比Git缺少的最大的一个特征。 4) Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 5) Git下载下来后，在OffLine状态下可以看到所有的Log,SVN不可以。 6) 刚开始用时很狗血的一点，SVN必须先Update才能Commit,忘记了合并时就会出现一些错误，git还是比较少的出现这种情况。 7) 克隆一份全新的目录以同样拥有五个分支来说，SVN是同时复製5个版本的文件,也就是说重复五次同样的动作。而Git只是获取文件的每个版本的 元素，然后只载入主要的分支(master)在我的经验,克隆一个拥有将近一万个提交(commit),五个分支,每个分支有大约1500个文件的 SVN,耗了将近一个小时！而Git只用了区区的1分钟！ 8) 版本库（repository):SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。而 Git可以有无限个版本库。或者，更正确的说法，每一个Git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）发生了什麼事，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！ 9)分支（Branch）在SVN，分支是一个完整的目录。且这个目录拥有完整的实际文件。如果工作成员想要开啟新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来进行破坏工作（安检测试），那将会像传染病一样,你改一个分支，还得让其他人重新切分支重新下载，十分狗血。而 Git，每个工作成员可以任意在自己的本地版本库开啟无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用， 我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可。无痛无痒。 Git的分支名是可以使用不同名字的。例如：我的本地分支名为OK，而在主要版本库的名字其实是master。 最值得一提，我可以在Git的任意一个提交点（commit point）开启分支！（其中一个方法是使用gitk –all 可观察整个提交记录，然后在任意点开啟分支。） 10)提交（Commit）在SVN，当你提交你的完成品时，它将直接记录到中央版本库。当你发现你的完成品存在严重问题时，你已经无法阻止事情的发生了。如果网路中断，你根本没办法提交！而Git的提交完全属於本地版本库的活动。而你只需“推”（git push）到主要版本库即可。Git的“推”其实是在执行“同步”（Sync）。 最后总结一下： SVN的特点是简单，只是需要一个放代码的地方时用是OK的。 Git的特点版本控制可以不依赖网络做任何事情，对分支和合并有更好的支持(当然这是开发者最关心的地方)，不过想各位能更好使用它，需要花点时间尝试下。 参考文档 git - 简明指南 图文详解 Git 的使用场景 Git版本控制软件结合GitHub从入门到精通常用命令学习手册","tags":[{"name":"Git","slug":"Git","permalink":"http://woshijingshenbing.com/tags/Git/"}]},{"title":"两个人的马尔代夫（未完待续）","date":"2016-10-15T15:16:38.000Z","path":"2016/10/15/两个人的马尔代夫/","text":"一次次的离开，一次次的归来，每次的感受都不相同，想写游记，却总怕写成一本本流水账，最烦流水账，既然是帐，都是要还的。但不记录下来，有些记忆真的会像流水一样，一去不复返，就像第一次骑行川藏公路上的点点滴滴，最有故事的行程，现在能想起的细节却已寥寥无几！等以后老的时候，彻底忘了自己经历过这件事，都是非常有可能。为了预防自己50年后，可能会有的老年痴呆，现在开始记录自己以往旅行中能回忆起的点点，以及将来旅行途中会遇到的滴滴。会有部分攻略，但不会太详细，因为网上这方面的资料很多，大部分内容还是自己的见闻和感受，想到哪写到哪喽。 选择马尔代夫前，还从想过自己会去这么一个地方，只是偶尔听说过，“一生必去（或50年后看不到）的50（或100）个景点之一”、“中国的马尔代夫：西沙群岛”、“爱她，就带她去马尔代夫”……各种夸张的词汇，无所无用其极。碰到这种帖子或新闻，我一般都会嗤之以鼻，拿着八千工资的小编，又来忽悠我们这些月薪三千的屌丝，月薪三万的人是怎样生活的，谁上当谁SB。像我这样一个，国内旅行(户外居多)超过1000元的都觉得贵的穷驴，怎么会被骗呢（不被骗的最好方式就是没钱）。 但人生就像一盒各式各样巧克力，我们永远不知道下一颗是什么味道，下一刻我们会做什么决定。碰巧领导推荐了一个双11阿里旅行的一个特惠活动，机酒全包；碰巧我有许多调休假期，自己又没有出行计划；碰巧有了另外一个人，两个人都爱旅游；碰巧……好吧，既然这么多碰巧，那就这样愉快的决定了吧!确定出行日期、制定出行计划、调整出行心情。可是，离出行还有半年时间，从11/11到次年5/6，这心情调整得够久的了。那就慢慢的准备着、等待着，喜悦着…等待是件奇妙的感觉，等待世界末日、等待金榜题名、等待慢慢变老、等待马尔代夫、等待戈多。 之前出国过一次，12年的尼泊尔，也给自己留下了深刻的印象，但那次是跟着朋友，朋友英语又很好，我就是一个小跟班。hello！ good morning. how much is this？cheaper？ thank you. can you speak a little slowly. 这就是我用到所有的英文词汇了。这次自己选择了一个陌生的地方，又带着一个小跟班，还是去这样一个传说的地方，忐忑没有不安，激动 all the time。 出发前的准备工作是必不可少的，机票和酒店都不用操心了，套餐里已包含，2999元/人，7天6晚，西安-马累往返，然后要做的就是确认出行时间，查看攻略，准备行李。 选择时间马尔代夫的5月-9月是雨季，会有比较多的雨水，甚至有些岛会一直下个不停，但由于马尔代夫是一条带鱼状的国家，南北长度有几百公里，所以每个环礁的雨季也有不同，详情可参考下面这个链接。http://www.mafengwo.cn/i/5326013.html 雨季为马尔代夫旅游的淡季，淡季价格会便宜一些，旺季价格会高一点。价格最贵的不是春节也不是国庆，而是圣诞节到元旦期间。像五一、端午、中秋这些假期，在马尔代夫都算是淡季，机票和酒店都会相对便宜。 我们购买的行程，3999北京往返，2999西安往返，时间12月~7月，每一个周四晚上9点，或周日凌晨1点出发。经过反复权衡，最终把乘机地点选在了西安（因为便宜），时间定在了6月5日，一个平常又特殊的星期天，有一些特殊的原因： 6月9日是端午节，会放三天假期，自己再请三天假，加上一个双休日，可以拼一个八天的假期； 凌晨出发，可以在飞机上睡觉，第二天7点多马代，不仅可以在飞机上看到日出，而且稍做休息，等于又多了一个白天； 6月5日是个特殊的日子：12年那天，从成都骑行出发去西藏，初生牛犊不怕虎；13年那天妈妈重病住院，高铁赶回家陪伴，第一次感到了害怕；14年那天，生活已趋于平淡，开始慢慢适应和融合，并不断告诫自己，生活就是这样；15年那天，和亲爱的她在纳木错旁看日出，开始体会平淡中的甜蜜，并意识到了自己未来要肩负起的责任。 选择岛屿马代的岛屿分为三类：酒店岛、居民岛、无人岛。 居民岛，岛上大部分都是本地居民，会有一些禁忌，例如不能吃猪肉、不能饮酒、不能在沙滩裸泳。有些攻略上说男生不能穿短裤，女生不能穿比基尼，但我们在沙滩上见到一个欧美女人穿比基尼游泳，好像也没什么问题，但最好还是入乡随俗。男生不能穿短裤，却纯粹是误传，见到大街上大批大批的当地人和外地游客穿短裤，没见什么不适。 酒店岛，就是所谓的度假岛，每座岛都有一个度假村，而且有且仅有一个，因为岛太小，一般都不到一平方公里，庙小，一个神就够。然后就各显神通，各有各的风格，特别是水屋的布局，每一种布局都是独一无二的艺术。度假岛上就没有这么多禁忌，美到不像话的海水和沙滩，配上各种肤色的比基尼美女，躺在沙滩上，或者游艇上，眼睛根本不够用，美景或者美女，这是一个问题。酒店岛上一般分海景房、沙屋和水屋。海景房就是出门走几步就是沙滩，再走几步就是大海；沙屋就是出门就是沙滩，走几步就是大海；水屋就是开门就是大海，或者屋内直接有楼梯可以直接走进大海。价格：水屋&gt;沙屋&gt;海景房。 无人岛，面积一般比较小，地势不太适合居住，或者只是还没来得及开发。但风景也是很漂亮的，当地会有一日游的团，会选择在居民岛或者无人岛上进行BBQ。如果预算充足，包条快艇，到一个无人岛上来一场裸体party，都不会有人管的。我曾经想过带帐篷到无人岛上扎营，但想到各种蜥蜴和蛇虫，最终作罢。 我们这次住的酒店在胡鲁马累上，首都马累岛旁边的一个居民岛，面积大概有五平方公里，面积算挺大的了，还在不断的填海扩岛，据说是为了等到首都马累岛被海水淹没后，可以把首都迁移到这里。我们住的酒店名称叫city grand，条件一般，不过挺干净，跟国内的七天、速八差不多。老板是孟加拉人，汉语很好，两个服务员是当地人，服务态度都挺和气的。我们去的是淡季，所以每天见不到什么其他住户，见也就只见一面，他们一般都是到这边过渡住一晚，第二天不是到酒店岛上开始假期，就是坐飞机离开马代结束假期。 我们在这一个地方睡了五晚，白天要么去对面四五十米外的海滩，要么去其他岛屿游玩，但晚上都会回到这个临时的家。住在四楼，他们那里却标着三楼，跟国内的楼层计数方式不同，一切从0开始，还是蛮实在的嘛。晚上海风挺大，很凉快，会有满天繁星，每天都有，第一天感觉美翻了，后面几天完全无感。只是不喜欢空调风，会到上面吹着海风，聊聊天，不想说话了，就看看下载的美剧，浪费着大把的时光。 这个是后面另一家酒店，这边的建筑一般都是这样，像一个个小盒子，而且有很多都是涂上单一的颜色，红的、黄的、蓝的，一切都那么鲜艳和明快。 个人建议：根据自己的预算，以及自己的旅行习惯来安排。各种主打旅游平台上，一两万的，机票酒店游玩一价全包的产品，一般都是在一个度假岛上，两沙两水，然后附送一些浮潜之类的海上项目。两三万的，会多几晚，多一个度假岛而已。再贵的，七八万，十几万的也有，那就是非常奢侈的海岛，各种总统套房和娱乐活动，多少钱都有地方花。我们没有太明确的目标，性价比是最重要的，对住宿没有太多要求，只为多体验些风土人情，。 如果不差钱，而且怕麻烦，就在阿里旅行、马蜂窝或其它平台上，购买一个全包的行程即可。如果爱折腾，喜欢新鲜感，可以选择跳岛游，浮潜、深潜或游轮，提前选好中意的小岛，在各团购网站盯着，有特价可早点下手。 注意事项居民岛和度假岛有差，但八九不离十。 吃：不要吃猪肉，你也吃不到。餐厅中都是鸡肉和鱼肉，金枪鱼炒饭，不好吃。中餐厅很贵，一盘土豆丝五六十，不过当地餐厅的随便一份炒饭也要五六十（人民币）。吃不吃在你，许多粮食和蔬菜都是空运或船运来的，当地农业不发达。 喝：不能喝酒，你也买不到。酒店里的矿泉水，喝之前要问下是否收费。我们住的房间有两瓶水，是免费提供的。但大部分酒店是收费的，认识的一上海哥们，他们住的度假岛，一瓶纯净水收了15美元，我想味道应该是独具当地特色的吧。 玩：去马累岛转悠，不要请导游，特别不要让酒店老板或主管帮你找导游。我们到的第一天不了解情况，八个中国人，被酒店的老板忽悠得请了一个导游，包含往返车费和船费，一人收了10美元。导游带我们转完送我们回来，又收了我们一人5美元，称为服务费。然后我们才明白了前面交的10美元=2美元交通费+8美元服务费。导游/天=(8+5)*8=104美元=676人民币。马累岛很小，就一平方公里，随便转都不会丢，也会把所有景点都逛到。 乐：没有酒吧，没有ktv。有的只是洁白的沙滩，和无穷无尽的海水。不能裸奔或裸泳，也不要盯着当地的女人看，会挨揍。况且，不好看，印度人那种黑，而且又瘦又小。 礼：如果别人帮助了你的话，需要给小费，每次一美元，是一种礼貌。我是礼貌人，所以上下车、上下楼提行李这种事，就不麻烦别人了。当然 Thank you 这个简单的口语是必需掌握的。 易：购物除了超市，其它地方都可以侃价，如果你英文可以的话。价格都会标的虚高，稍微砍下就可以，不行就换一家，商店挺多，货比三家。如果是去度假岛游玩，最好在居民岛买点水带上，一瓶2.5L的纯净水，大概15卢比，折合人民币7块钱，还是蛮便宜。 居：许多地方都可以步行到达，不要随便打的，炒鸡贵。坐大巴，记得带点当地零钱，不然付美元会很吃亏。许多居民岛都可以坐船到达，也有自己的特色，例如浮潜、深潜等，如果碰到特价机票，可以到马代跳岛游，花费不会太贵。水上飞机很贵，如果单纯的坐飞机到上面溜达溜达，半个小时差不多要300美元左右。 住：一定要带防蚊虫的东西，电蚊香、蚊香片、驱蚊水。那边的蚊子个头很小，防不胜防，满脚是疙瘩的照片就不放出来了，自己看了都吓一跳。我把宝贵的献血洒在了几千公里外的小岛….不过我女朋友没被咬一口，不知为何。不是我女朋友的，就不要冒着个险了。 花费（两个人） 机票+酒店：2999*2=5998 火车票：300+1000=1300（北京-西安往返火车） 机场大巴：2022=80（西安火车站-咸阳机场） 马代花销：518$*6.5=3367（在马代的所有花销） 西安花销：300（吃饭+其他） 水下相机租用：10*10+40=140（10元/天，40元免赔保险） 其它：300（方便面、辣条、面包、防水袋、晾衣绳等） 保险：15*2=30（境外财产险，物品丢失可以报一部分） 合计：约 11500 元 特别注意：带足美金，比预算多个一两百，不然万一真有什么事儿的话很麻烦的，这边人民尤爱美金，人民币可以兑换，但不能直接消费。不要换太多当地货币，不然最后真的没地方扔，当地人都不喜欢，拿当地货币换美金，想都别想（或者超高的兑换利率）。 物品清单不列太详细的，列一些自己觉得必备的。 沙滩鞋（游泳或浮潜的时候，会知道这个多么重要） 防水袋（雨水较多，而且那边潮气很大，放衣服和证件） 护照前两页复印件、一寸照片两张 入境卡填写样本复印件（对英语不好的特别有用） 旅行翻译官 app 移动wifi（租金10元/天，淘宝上有，重度手机患者必备） 驱蚊片（我们带的花露水，一点都不管用） 防晒服+帽子+墨镜+防晒霜（防晒组合套件，其实觉得对男生没什么用，不晒黑你跑赤道干啥） 地理位置马尔代夫，位于印度洋，斯里兰卡南部的一片群岛，地球上最大的珊瑚岛国，由1200余个小岛组成， 其中202个小岛有人居住，87个是度假岛。伊斯兰是他们的国教，全民信教，每天五次祷告。没有自己的军队，只有一个1000多人的自卫队，但治安还不错。之前一直误以为斯里兰卡是南非东边的一个岛，马尔代夫是菲律宾，或泰国的一个小岛，真的是太没见识，高中的地理知识都给狗吃了。 马尔代夫被称为上帝失落在印度洋上的珍珠，因为上千个岛屿，零星的散落在蔚蓝广阔的大洋上，从飞机上俯瞰，有种大珠小珠落玉盘的意境，顾以此成名。整体的岛屿分布图如下所示，绿色的为小岛，浅绿色的为环礁，首都马累（32）正好处于中间，在赤道附近，如果要到南部的岛屿游玩，就等于到南半球，地球的另一半逛了一圈，想想还是蛮激动的。 参考链接 穷游马尔代夫 4000元跳岛旅行 关于浮潜的重要事项及经验（没浮潜过的朋友请看过来） 菜鸟浮潜攻略","tags":[{"name":"游记","slug":"游记","permalink":"http://woshijingshenbing.com/tags/游记/"},{"name":"马尔代夫","slug":"马尔代夫","permalink":"http://woshijingshenbing.com/tags/马尔代夫/"}]},{"title":"京城浮生","date":"2016-10-02T17:12:12.000Z","path":"2016/10/03/京城浮生/","text":"十一长假已经快过去了两天，还有五天，但我依旧会宅在北京。 第一天跟朋友去见一个老板，可能后期会有合作，希望可以有些靠谱的项目做，补充一下钱袋子，可以解一下燃眉之急。晚上见了一位前同事，一起吐槽了下曾经苦逼的岁月，以及对未来的规划。好多事情去做，好多事情想去做，好多事情又急不得。 第二天中午自然醒，些许头疼，嗓子有北京雾霾天特有的不舒服，昨晚又忘了关窗，该死。下了面条，做了三个菜，一个人全吃完，莫名其妙的感到无比满足，已经基本解决温饱问题了。想起过去几年这个时刻，我都在不同的地方浪荡，遇到不同的人，路过不同的人。 第三天… 第四天… 第五天… 第六天… 第七天… 中秋节见了丈母娘，十天后又交了房子首付，这些大事都发生的太快了，一切都超出了自己的预期，或者说自己之前都没有预期。跟旅途中朋友吹牛，自己三十岁之前不可能买房，不可能稳定一段关系，不可能成为愚蠢的房奴，不可能被一份工作，或一座城市牵绊住的脚本。可是现在牛皮都破了，我不敢随意的辞职，不敢今朝有酒今朝醉，不敢不负责，不敢说走就走。这一刻才明白，以前可以随便放下，是因为那时自己从未拥有，光脚的不怕，穿鞋的怕，大概就是这个道理。 北京慢慢失去了刚开始的诱惑力，雾霾越来越重，城市越来越挤，房价越来越贵，却反而让我越来越离不开。在河北涿州买过房之后，朋友笑谈，终于翻身做了主人，自己只能苦笑回应，终于翻身做了邻居。涿州人民一直期盼着自己可以划入北京，拆除两家人之间的围墙，可是赵家人和王家人，哪有那么容易就成一家人了。隔壁老王，你想太多。 “别人贪婪时我恐惧，别人恐惧时候我贪婪”、“当大部分都觉得是机会时，就不是机会了”、“世界上没有不破的泡沫”…道理都懂，但依旧过不好这一生! 我是中国人，我为这个感到自豪，因为我们有五千年璀璨的历史，我们的人民顽强不息，我们歌颂着我们的祖国，但我们为什么又这么缺乏安全感？ 长大是一次次世界观被推翻的过程，长大是欲望一次次膨胀的过程，长大是越来越像大人一样做事的过程。我在恐惧中买了房，去年七千没买，今年翻番，明年会怎样的？房子不是刚需，但婚姻和教育是，五年后、十年后，我可以不在乎自己境况如何，但不能不在乎我在乎的人。爸爸告诉我好好读书，长大后才会有高工资，会有好的生活。妈妈告诉我诚实勤劳，跟周围人处好关系，好好照顾自己。可我现在北京，看着朋友一个个离开北京，或者将要离开北京，看着房价一天一个样，我越来越恐惧，我的欲望开始膨胀，我想在北京有一座房子，我想像一个大人一样，把爸爸接到身边，给未来的baby一个家，老吾老，幼吾幼，这么简单，又这么难。 如果有一天，六环修到了七环，修到了七环怎么办，它比五环多两环。怕再多修几环，就被挤回老家了，于是我在北京七环，在河北买了房。我的恐惧，变成了贪婪。 生命诚可贵,爱情价更高。若为自由故,两者皆可抛。但为了房子，放弃了自由，是否可以说房子是最贵的呢？25岁之后，身体就开始走下坡路，特别是从去年到今年，洗头的时候头发也是大把大把的掉，不像前几年，周末不出去蹦跶两天，周一去上班根本就是无精打采。去年封闭开发加班，每天10点下班回酒店睡觉，早上去跑步，总会在紫竹院公园看到成批的老年人晨练，会经常有这样的念头，他们大部分在一个地方工作、生活了一辈子，现在年老了，时间自由了，财务也自由了，为什么还是呆在一个地方，每天所做的只是蹬蹬腿、伸伸腰、跳跳广场舞，为什么不想着去远方看看？去冰岛看看极光、去南极看看企鹅，去喜马拉雅山脉眺望远处雪山上那神圣的光、去海底潜水与热带鱼共舞、去原始森林与大猩猩握手…. 他们或许不曾拥有，就谈不上失去。亦或许他们曾经也应为房子失去了自由，但失去就是失去了，就不再去奢望拥有。然而最可能的原因，只是他们身体已经不允许他们去做这些事情了。年轻时一个欲望接着一个欲望，当年老时，失去所有的欲望，这种状态是好是坏，我也说不上。欲望是天使，欲望也是魔鬼，我希望掌控它，可常常却是被它掌控。 现在的欲望很简单，很俗，希望工资越来越高，希望房贷尽快还完，希望越来越有钱，毕竟精神的自由，大部分都是建立在经济自由之上的。未来的欲望不简单，希望自己在35岁可以实现财务自由，成为一名独立开发者。35岁时，那时自己的孩子应该四五岁了吧，开始记事了，自己可以陪在他身边，晚上陪他一起打游戏，但必须做完作业后才可以。周末带他去爬爬山，暑假或寒假带他去远行，他要自己收拾行李，路上会认识很多小伙伴，见识各种各样的生活方式。当它十二三岁时，带他骑车去西藏，我在前面带路，他小车在中间，妈妈在最后面边骑边推。当他想爷爷，亦或姥爷时候，随时都可以带他回去，而不用体验那该死的国庆高速游，以及愚蠢的春运体育课。 未来是最美好的，现实是最残酷的。鸡汤该喝还得喝，解决不了我们的问题，它又不是中药，没这义务，但它可以强健体魄，路还很长，我们都要健健康康的。30岁不是终点，30岁才是起点，年少的无知快乐不是真的幸福，认识的世界的残酷，仍然可以继续快乐的走下去，才是真正的幸福。 一不小心又熬夜了，12点37了，睡觉。","tags":[{"name":"买房","slug":"买房","permalink":"http://woshijingshenbing.com/tags/买房/"},{"name":"北京","slug":"北京","permalink":"http://woshijingshenbing.com/tags/北京/"}]},{"title":"pycharm随记","date":"2016-05-03T04:02:03.000Z","path":"2016/05/03/pycharm随记/","text":"概述pycharm是一款重量级的IDE,天生为python程序开发而生,尽管有人会说vim或sublime配置好了也是神器,但pycharm难道就不是了吗? 快捷键提示 CTRL 空格: 在参数列表位置，显示可以输入的所有参数 CTRL Q: 查看选中方法的文档字符串 阅读 CTRL -: 折叠当前代码 CTRL +: 展开当前代码 CTRL (SHIFT) -: 折叠(所有)代码 CTRL (SHIFT) +: 展开(所有)代码 CTRL F11 | F11: 设置书签. SHIFT F11: 显示所有书签。 CTRL F12: 当一个文件中方法太多，要快速跳到某个方法时，可以用此快捷键打开LIST。 CTRL E: 最近访问的文件列表 ESC: 焦点从其它窗口到编辑窗口 SHIFT ESC: 隐藏当前窗口，焦点到编辑窗口 F12: 焦点从编辑窗口到上一个使用窗口 移动 ALT UP: 移到上一个方法 ALT DOWN: 移到下一个方法 CTRL B | CTRL 单击： 转到方法定义处(ALT ← 返回到跳转处) CTRL SHIFT UP: 将当前定义上移一行 CTRL SHIFT UP: 将当前定义下移一行 CTRL ALT UP: 将当前行上移一行 CTRL ALT UP: 将当前行下移一行 SHIFT ENTER: 在行中间执行时，跳转到下一行，并插入一空行。 CTRL ENTER: 在行中间执行时，跳转到上一行，并插入一空行。 编辑 CTRL D: 未选中时，复制当前行到下一行，选中时复制粘贴选中部分。 CTRL J: 输入模板 CTRL ALT T: 引入代码块 CTRL ALT L: 选中的代码格式化 CTRY Y: 删除当前行 其它Alt + Enter: 快速提示操作的快捷菜单CTRL F8: 设置/取消断点编辑器右键，local history, show history： 显示本地修改记录 设置设置行号File –&gt; Settings –&gt;Editor –&gt;Appearance , 之后勾选Show Line Numbers 滚轮改变大小和自动换行Setting -&gt;Editor-〉General 中设置 设置字体大小Settings–&gt;Editor–&gt;Colors &amp; Fonts–&gt;Font pycharm 不支持 svn 时怎么处理(for windows) 到http://download.csdn.net/detail/u013177568/7723151下载svn命令行安装包例如：安装到 D:\\software\\svn目录下 安装成功后，打开 File -&gt;Settings -&gt; Version Control -&gt;Subversion-&gt;General 配置如下两点：a ：Use command line client 指到 D:\\software\\svn\\bin\\svn.exeb： Use system default Subversion configuration directory 指向 D:\\softfware\\svn\\bin即可 实用功能实时比较PyCharm 对一个文件里你做的改动保持实时的跟踪，通过在编辑器的左侧栏显示一个蓝色的标记。 点击那个标记，会显示出之前的内容以及一个工具栏，很容易地回滚这些改动，在一个详尽的对话框中查看这些改动或是将之前的文本粘贴到剪切板上。 提交时的比较预览提交时可以查看对比当前变化的文件，并可以实时的进行修改。 提交时检查在提交过程中，我们还可以在实际提交前执行其他一些选项，像格式化代码，优化导入（排序并移除未使用过的导入），检查变动集合中的待完成项 等等。 自动重命名重命名时用 SHIFT + F6 组合键，不管是方法名、变量名，甚至是文件名或文件夹名，会将所有引用的地方或路径一起修改过来。","tags":[{"name":"pycharm","slug":"pycharm","permalink":"http://woshijingshenbing.com/tags/pycharm/"},{"name":"随记","slug":"随记","permalink":"http://woshijingshenbing.com/tags/随记/"}]},{"title":"python并发编程","date":"2015-11-11T03:12:12.000Z","path":"2015/11/11/python并发编程/","text":"概述 进程：Python中一般使用multiprocessing/subprocess来实现 线程：threading/thread是Python中用来实现多线程的模块 协程（Coroutines）：Python中用于处理协程的模块倒是比较多，有eventlet、Twisted、Tulip、asyncio 线程多线程几乎是每一个程序猿在使用每一种语言时都会首先想到用于解决并发的工具（JS程序员请回避），使用多线程可以有效的 利用CPU资源（Python例外）。然而多线程所带来的程序的复杂度也不可避免，尤其是对竞争资源的同步问题。 然而在python中由于使用了全局解释锁（GIL）的原因，代码并不能同时在多核上并发的运行，也就是说， Python的多线程不能并发，很多人会发现 使用多线程来改进自己的Python代码后，程序的运行效率却下降了， 这是多么蛋疼的一件事呀！如果想了解更多细节，推荐阅读这篇文章。 实际上使用多线程的编程模型是很困难的，程序员很容易犯错，这并不是程序员的错误，因为并行思维是反人类的， 我们大多数人的思维是串行（精神分裂不讨 论），而且冯诺依曼设计的计算机架构也是以顺序执行为基础的。 所以如果你总是不能把你的多线程程序搞定，恭喜你，你是个思维正常的程序猿：） Python提供两组线程的接口，一组是thread模块，提供基础的，低等级（Low Level）接口， 使用Function作为线程的运行体。还有一组是threading模块，提供更容易使用的基于对象的接口（类似于Java）， 可以 继承Thread对象来实现线程，还提供了其它一些线程相关的对象，例如Timer，Lock 使用thread模块的例子 import thread def worker(): &quot;&quot;&quot;thread worker function&quot;&quot;&quot; print &apos;Worker&apos; thread.start_new_thread(worker) 使用threading模块的例子 import threading def worker(): &quot;&quot;&quot;thread worker function&quot;&quot;&quot; print &apos;Worker&apos; t = threading.Thread(target=worker) t.start() 或者Java Style import threading class worker(threading.Thread): def __init__(self): pass def run(): &quot;&quot;&quot;thread worker function&quot;&quot;&quot; print &apos;Worker&apos; t = worker() t.start() 进程 （Process）由于前文提到的全局解释锁的问题，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源， 并实现真正意义上的并发。当然，进程的开销比线程要大，也就是说如果你要创建数量惊人的并发进程的话， 需要考虑一下你的机器是不是有一颗强大的心。 单个进程示例： import multiprocessing import time def worker(interval): n = 3 while n &gt; 0: print(&quot;The time is {0}&quot;.format(time.ctime())) time.sleep(interval) n -= 1 if __name__ == &quot;__main__&quot;: p = multiprocessing.Process(target = worker, args = (3,)) p.start() print &quot;p.pid:&quot;, p.pid print &quot;p.name:&quot;, p.name print &quot;p.is_alive:&quot;, p.is_alive() 多个进程示例： import multiprocessing import time def worker_1(interval): print &quot;worker_1&quot; time.sleep(interval) print &quot;end worker_1&quot; def worker_2(interval): print &quot;worker_2&quot; time.sleep(interval) print &quot;end worker_2&quot; def worker_3(interval): print &quot;worker_3&quot; time.sleep(interval) print &quot;end worker_3&quot; if __name__ == &quot;__main__&quot;: p1 = multiprocessing.Process(target = worker_1, args = (2,)) p2 = multiprocessing.Process(target = worker_2, args = (3,)) p3 = multiprocessing.Process(target = worker_3, args = (4,)) p1.start() p2.start() p3.start() print(&quot;The number of CPU is:&quot; + str(multiprocessing.cpu_count())) for p in multiprocessing.active_children(): print(&quot;child p.name:&quot; + p.name + &quot;\\tp.id:&quot; + str(p.pid)) print &quot;END!!!!!!!!!!!!!!!!!&quot; 打印结果： The number of CPU is:4 child p.name:Process-3 p.id:8276 child p.name:Process-2 p.id:6552 child p.name:Process-1 p.id:7340 END!!!!!!!!!!!!!!!!! 多线程和多进程（注意锁的用法） #!/usr/bin/python # -*- coding:utf-8 -*- import os import threading import multiprocessing count_thread = 0 count_process = 0 # worker function def worker1(sign, lock): global count_thread lock.acquire() count_thread += 1 print(sign, os.getpid()) lock.release() def worker2(sign, lock): global count_process lock.acquire() count_process += 1 print(sign, os.getpid()) lock.release() if __name__ == &apos;__main__&apos;: # Main print(&apos;Main:&apos;,os.getpid()) # Multi-thread record = [] lock = threading.Lock() for i in range(5): thread = threading.Thread(target=worker1,args=(&apos;thread&apos;,lock)) thread.start() record.append(thread) for thread in record: thread.join() # Multi-process record = [] lock = multiprocessing.Lock() for i in range(5): process = multiprocessing.Process(target=worker2,args=(&apos;process&apos;,lock)) process.start() record.append(process) for process in record: process.join() print count_thread print count_process 打印结果： (&apos;Main:&apos;, 6688) (&apos;thread&apos;, 6688) (&apos;thread&apos;, 6688) (&apos;thread&apos;, 6688) (&apos;thread&apos;, 6688) (&apos;thread&apos;, 6688) (&apos;process&apos;, 7820) (&apos;process&apos;, 6596) (&apos;process&apos;, 9068) (&apos;process&apos;, 8256) (&apos;process&apos;, 6212) 5 0 [Finished in 0.2s] 由于线程共享相同的地址空间和内存，所以线程之间的通信是非常容易的，然而进程之间的通信就要复杂一些了。常见的进程间通信有，管道，消息队列，Socket接口（TCP/IP）等等。Python的mutliprocess模块提供了封装好的管道和队列，可以方便的在进程间传递消息。Python进程间的同步使用锁，这一点和线程是一样的。另外，Python还提供了进程池Pool对象，可以方便的管理和控制线程。 协程还有一种并发手段并不常见，我们可以称之为伪线程，或者称为协程，就是看上去像是线程，使用的接口类似线程接口，但是实际使用非线程的方式，对应的线程开销也不存的。 greenlet提供轻量级的coroutines来支持进程内的并发。 greenlet是Stackless的一个副产品，使用tasklet来支持一中被称之为微线程（mirco－thread）的技术，这里是一个使用greenlet的伪线程的例子 from greenlet import greenlet def test1(): print 12 gr2.switch() print 34 def test2(): print 56 gr1.switch() print 78 gr1 = greenlet(test1) gr2 = greenlet(test2) gr1.switch() 运行以上程序得到如下结果： 12 56 34 伪线程gr1 switch会打印12，然后调用gr2 switch得到56，然后switch回到gr1，打印34，然后伪线程gr1结束，程序退出，所以78永远不会被打印。通过这个例子我们可以看出，使用伪线程，我们可以有效的控制程序的执行流程，但是伪线程并不存在真正意义上的并发。 各种测试用例参考： http://www.open-open.com/lib/view/open1426919121601.html 通过测试我们可以发现，对于IO密集型的任务，使用多线程，或者是多进程都可以有效的提高程序的效率，而使用伪线程性能提升非常显著，eventlet比 没有并发的情况下，响应时间从9秒提高到0.03秒。同时eventlet／gevent提供了非阻塞的异步调用模式，非常方便。这里推荐使用线程或者伪 线程，因为在响应时间类似的情况下，线程和伪线程消耗的资源更少。 总结Python提供了不同的并发方式，对应于不同的场景，我们需要选择不同的方式进行并发。选择合适的方式，不但要对该方法的原理有所了解，还应该做一些测试和试验，数据才是你做选择的最好参考。 参考python多进程编程使用Python进行并发编程","tags":[{"name":"python","slug":"python","permalink":"http://woshijingshenbing.com/tags/python/"},{"name":"并发","slug":"并发","permalink":"http://woshijingshenbing.com/tags/并发/"},{"name":"线程","slug":"线程","permalink":"http://woshijingshenbing.com/tags/线程/"},{"name":"进程","slug":"进程","permalink":"http://woshijingshenbing.com/tags/进程/"},{"name":"协程","slug":"协程","permalink":"http://woshijingshenbing.com/tags/协程/"}]},{"title":"实现定时任务的多种方式","date":"2015-11-07T11:42:14.000Z","path":"2015/11/07/crontab调用python脚本的注意事项/","text":"概览 crontab celery crontab 查看： crontab -l 编辑： crontab -e 重启服务： service crond restart 语法格式格式如下: f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。值的范围分别对应0－59，0－23，1－31，1－12，0－7（0和7都代表星期天）。program 表示要执行的程式。 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其余类推 当 f1 为 */n 时表示每 n 分钟执行一次，f2 为 */n 表示每 n 小时执行一次，其余类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其余类推 任何一个字段中的一个星号都是一个通配符。如果第一个字段含有一个星号，那个作业每分钟运行一次，以此类推，第二个字段含有通配符那就是每小时执行一次 每周六早上10点重启应用。0 10 * * 6 sh /home/alexzhou/bin/restart_tuli.sh 每周二和每月的初一，十五的早上2点钟，更新solr索引。0 2 1,15 * 2 python /home/alexzhou/update_index.py 调用 python 脚本时注意实现 如果程序是从 if __name__ == &quot;__main__&quot;: 开始执行的话，在shell中可以运行执行，但在 crontab 中不能执行，所以脚本要调用的函数不能在 if __name__ == &quot;__main__&quot;: 中 1234def run(): print \"run\"if __name__ == \"__main__\": run（） 上面的脚本不会在crontab中运行， 需要改成如下方式： 123def run(): print \"run\"run() 当前目录的问题，配置文件等要使用绝对路径 1logging.config.fileConfig(\"log.conf\") 由于 crontab 执行时，脚本的当前目录已经改变，此时 log.conf 会找不到，会造成程序错误退出。 要修改为如下方式： 1logging.config.fileConfig(\"/home/terry/python/web/log.conf\")","tags":[{"name":"定时任务","slug":"定时任务","permalink":"http://woshijingshenbing.com/tags/定时任务/"}]},{"title":"编写高质量代码（改善python程序的91个建议）","date":"2015-11-07T11:42:14.000Z","path":"2015/11/07/编写高质量代码（改善python程序的91个建议）/","text":"概述一些小tip,不用刻意去记,大致知道有这么个用法,慢慢就潜移默化到平时的编程中了. 掌握字符串的基本用法 判断是否为字符串，用 isinstance(a, basestring)，而不是用str或unicode，因为str和unicode都为basestring的子类，用它们的话会有遗失情况。 123456789&gt;&gt;&gt; a = '123'&gt;&gt;&gt; a'123'&gt;&gt;&gt; isinstance(a, str)True&gt;&gt;&gt; isinstance(a, unicode)False&gt;&gt;&gt; isinstance(a, basestring)True 判断是否包含子串用 in 1234&gt;&gt;&gt; str = \"Test if a string contains some special substrings\"&gt;&gt;&gt; print \"some\" in strTrue&gt;&gt;&gt; repace(old,new,[,count])用以替换字符串中的某些子串，如果指定count参数的话，就最多替换count次，如果不指定，就全部替换（跟其他语言不太一样，要注意）。 字符串s.split()和s.split(‘ ‘)返回值是不一样的 12345&gt;&gt;&gt; a = ' hello world'&gt;&gt;&gt; a.split()['hello', 'world']&gt;&gt;&gt; a.split(' ')['', hello', '', '', 'world'] 产生差异的原因在于：当忽略 sep 参数或 sep 参数为 None 时与明确给 sep 赋予字符串值时，split()采用两种不同的算法。 对于前者，split() 先去除字符串两端的空白符，然后以任意长度的空白符串作为界定符分切字符串（即连续的空白符串被当作单一的空白符看待）； 对于后者则认为两个连续的 sep 之间存在一个空字符串。因此对于空字符串（或空白符串），它们的返回值也是不同的。 1234&gt;&gt;&gt; ''.split()[]&gt;&gt;&gt; ''.split(' ')[''] 首字母大写，capwords和title是不一样的，前者会移除前后空白符，并把多个空格合并成一个，后者只是简单的首字符大写，无其它操作。 12345&gt;&gt;&gt; import string&gt;&gt;&gt; string.capwords(' hello world!')'Hello World!'&gt;&gt;&gt; ' hello world!'.title()' Hello World!' 删除末端的逗号，或者掐头去尾（strip([char])、lstrip([char])、rstrip([char])） 12&gt;&gt;&gt; a = '1,2,3,4,'&gt;&gt;&gt; a.rstrip(',') 漂亮的字符串输出，可以用在打印日志调试时 1234567&gt;&gt;&gt; a = '1,2,3,4'&gt;&gt;&gt; print a.center(30, '*')***********1,2,3,4************&gt;&gt;&gt; print a.ljust(30, '*')1,2,3,4***********************&gt;&gt;&gt; print a.rjust(30, '*')***********************1,2,3,4 按需选择 sort() 或者 sorted() 相比于 sort()，sorted() 使用的范围更为广泛，两者的函数形式分别如下： sorted(iterable[, cmp[, key[, reverse]]]) s.sort([cmp[, key[, reverse]]]) 这两个方法有以下 3 个共同的参数： cmp 为用户定义的任何比较函数，函数的参数为两个可比较的元素（来自iterable 或者 list），函数根据第一个参数与第二个参数的关系依次返回 -1、0 或者 +1（第一个参数小于第二个参数则返回负数）。该参数默认值为 None。 key 是带一个参数的函数，用来为每个元素提取比较值，默认为 None（即直接比较每个元素）。 reverse 表示排序结果是否反转。 从函数的定义形式可以看出， sorted() 作用于任意可迭代的对象，而 sort() 一般作用于列表。 因此下面的例子中针对元组使用 sort() 方法会抛出 AttributeError，而使用 sorted() 函数则没有这个问题。 示例一： 123456789&gt;&gt;&gt; a = (4,2,1,3)&gt;&gt;&gt; a.sort()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'tuple' object has no attribute 'sort'&gt;&gt;&gt; sorted(a)[1, 2, 3, 4]&gt;&gt;&gt; a = [1,2,3,4]&gt;&gt;&gt; a.sort() 示例二： 12345&gt;&gt;&gt; persons = [&#123;'name': 'Jon', 'age': 32&#125;, &#123;'name': 'Alan', 'age': 50&#125;, &#123;'name': 'Bob', 'age': 23&#125;]&gt;&gt;&gt; sorted(persons, key=lambda x: -x['age'])[&#123;'age': 50, 'name': 'Alan'&#125;, &#123;'age': 32, 'name': 'Jon'&#125;, &#123;'age': 23, 'name': 'Bob'&#125;]&gt;&gt;&gt; sorted(persons, key=lambda x: (x['name'], -x['age']))[&#123;'age': 50, 'name': 'Alan'&#125;, &#123;'age': 23, 'name': 'Bob'&#125;, &#123;'age': 32, 'name': 'Jon'&#125;] sorted() 函数会返回一个排序后的列表，原有列表保持不变；而 sort() 函数会直接修改原有列表，函数返 None。 123456789&gt;&gt;&gt; a = ['1', 1, 'a', 3, 7, 'n']&gt;&gt;&gt; sorted(a)[1, 3, 7, '1', 'a', 'n']&gt;&gt;&gt; a['1', 1, 'a', 3, 7, 'n']&gt;&gt;&gt; print a.sort()None&gt;&gt;&gt; a[1, 3, 7, '1', 'a', 'n'] 因此如果实际应用过程中需要保留原有列表，使用 sorted() 函数较为适合，否则可以选择 sort() 函数，因为 sort() 函数不需要复制原有列表，消耗的内存较少，效率也较高。 无论是 sort() 还是 sorted() 函数，传入参数 key 比 cmp 效率要高。 sorted()的强大功能 对字典进行排序：下面的例子中根据字典的值进行排序，即将phonebook对应的电话号码按照数字大小进行排序。 12345&gt;&gt;&gt; phonebook = &#123;'linda': '7750', 'bob': '7829', 'carol': '5834'&#125;&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; sorted_db = sorted(phonebook.iteritems(), key=itemgetter(1))&gt;&gt;&gt; print sorted_db[('carol', '5834'), ('linda', '7750'), ('bob', '7829')] 多维list排序… 字典中混合list排序… list中混合字典排序… … 使用 copy 模块深拷贝对象 浅拷贝（shallow copy）：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。浅拷贝的实现方式有多种，如工厂函数、切片操作、copy模块中的copy操作等。 深拷贝（deep copy）：也构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续执行拷贝，因此产生的对象不受其他引用对象操作的影响。深拷贝的实现需要依赖 copy 模块的deepcopy()操作。 使用 Counter 进行计数统计12345678910&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; some_data = ['1', '2', 2, 4, 5, '2', 'b', '2']&gt;&gt;&gt; a = Counter(some_data)&gt;&gt;&gt; print aCounter(&#123;'2': 3, 2: 1, 'b': 1, 4: 1, 5: 1, '1': 1&#125;)&gt;&gt;&gt; a.most_common(2) # 频率最高的元素和它们的次数[('2', 3), (2, 1)]&gt;&gt;&gt; a.update('234b1') # 对原有计数器对象中元素的相加&gt;&gt;&gt; aCounter(&#123;'2': 4, 'b': 2, '1': 2, 2: 1, 4: 1, 5: 1, '3': 1, '4': 1&#125;) Counter 类是自Python2.7起增加的，属于字典类的子类，是一个容器对象，主要用来统计散列对象，支持集合操作 +、-、&amp;、|，其中 &amp; 和 | 操作分别返 Counter 对象各元素的最小值和最大值。 使用 logging 记录日志信息使用 threading模块都可以进行多线程的处理，threading 基于 thread 进行包装，将线程的操作对象化，在语言层面提供了丰富的特性，实际应用中推荐优先使用 threading 模块。 threading 模块对同步原语的支持更为完善和丰富。就线程的同步和互斥来说，thread 模块只提供了一种锁类型 thread.LockType，而 threading 模块中不仅有 Lock 令锁、RLock 可重入指令锁，还支持条件变量 Condition、信号量 Semaphore、BoundedSemaphore 以及 Event 事件等。 threading 模块在主线程和子线程交互上更为友好，threading 中的 join() 方法能够阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的 timeout（可选参数）。利用该方法可以方便地控制主线程和子线程以及子线程之间的执行。 thread 模块不支持守护线程。thread 模块中主线程退出的时候，所有的子线程不论是否还在工作，都会被强制结束，并且没有任何警告，也没有任何退出前的清理工作。 12345678910111213141516171819202122232425import timedef myfunc(a,delay): print \"I will calculate square of %s after delay for %s\" %(a,delay) time.sleep(delay) print \"calculate begins...\" result = a*a print result return result## thread 的处理方式，主线程不等子线程结束直接退出 # from thread import start_new_thread# start_new_thread(myfunc,(2,5))# start_new_thread(myfunc,(6,8))# time.sleep(1)# threading 的处理方式import threadingt1=threading.Thread(target=myfunc,args=(2,5))t2=threading.Thread(target=myfunc,args=(6,8))print t1.isDaemon() # 默认是False，会被主线程等待print t2.isDaemon() t2.setDaemon(True) # 设置为True后，会被主线程遗弃t1.start()t2.start() python3 中已经不存在 thread 模块了。 使用 Queue 使多线程编程更安全深入掌握 ConfigParser几乎所有的应用程序真正运行起来的时候，都会读取一个或几个配置文件。配置文件的意义在于用户不需要修改代码，就可以改变应用程序的行为，让它更好地为应用服务。基本用法通过手册可以掌握，这里只是介绍几个值得注意的知识点： 除了 0 之外，no、false 和 off 都会被转义为 False，而对应的 1、yes、true 和 on则都被转义为 True，其他值都会导致抛出 ValueError 异常 在支持的配置文件格式里，有一个 [DEFAULT] 节，当读取的配置项在不在指定的节里时， 将会到 [DEFAULT] 节中查找。 支持类似python中的字符串格式化 $ cat format.conf 1234567891011121314[DEFAULT]conn_str = %(dbn)s: %(user)s:%(pw)s@%(host)s:%(port)s/%(db)sdbn = mysqluser = roothost=localhostport=3306 [db1]user = aaapw=pppdb=example [db2]host = 192.168.0.110pw=wwwdb=example 通过这个配置文件能够获取不同的数据库配置相应的连接字符串，即 conn_str。如你所见，conn_str 定义在 [DEFAULT] 中，但当它通过不同的节名来获取格式化后的值时，根据不同配置，得到不同的值。参考如下代码： $ cat readformatini.py 12345import ConfigParserconf = ConfigParser.ConfigParser()conf.read('format.conf')print conf.get('db1', 'conn_str')print conf.get('db2', 'conn_str') 使用 argparse 处理命令行参数使用 pandas 处理大型 CSV 文件一般情况使用 ElementTree 解析 XML理解模块 pickle 优劣序列化的另一个不错选择 — JSON","tags":[{"name":"python","slug":"python","permalink":"http://woshijingshenbing.com/tags/python/"}]},{"title":"HTTP知识点总结","date":"2015-10-07T12:12:34.000Z","path":"2015/10/07/HTTP知识点总结/","text":"工作四年来，用过.net和python，写过cs，也写过bs，但无论如何都得跟Http打交道。服务器端和客户端的通信， 从刚开始的代码堆砌，纯粹的CRUD，到慢慢熟悉相关原理，也越来越感受到编程的乐趣。今天看到一篇好文章， 铺得比较开，都是工作几年真正接触到的东西，以前自己有点似是而非的东西，也给讲清了，更重要的，点到而止， 再深就不合适了。 TCP/IP协议族通常所说的网络（包括互联网），是在TCP/IP协议族的基础上运作的，而HTTP是它的一个子集。TCP/IP协议族可以分为4层，分别是应用层、传输层、网络层和链路层。下面分别介绍一下各层的作用： 应用层：决定了向用户提供应用服务时通信的活动。FTP（File Transfer Protocol， 文件传输协议）、DNS（Domain Name System，域名系统）和HTTP都属于该层。 传输层：提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据协议）都属于该层。 网络层：用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层：用来处理网络的硬件部分，包括操作系统、硬件的设备驱动、NIC（Network Interface Card，网卡）、光纤、诸如连接器之类的传输媒介等物理可见部分。 三次握手我们知道TCP和UDP主要的区别是UDP只负责发送，不确保一定送达；而TCP提供可靠的字节流服务（Byte Stream Service），采用三次握手策略确保数据送达。三次握手的过程使用了TCP 标志——SYN（synchronize）和ACK（acknowledgement）： 发送端发送一个带SYN标志的数据包给对方。 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 发送端回传一个带ACK标志的数据包，表示握手结束。 HTTP通信利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通讯。以HTTP举例来说，过程是这样的： 客户端在应用层（HTTP协议）发出一项想看某个Web页面的HTTP请求。 在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。经过以上步骤，一个网络请求就准备齐全了。经过网络传输之后，接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。到了应用层才算真正接收到由客户端发送过来的HTTP请求。 发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息；反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法，也叫封装（encapsulate）。 HTTP请求HTTP协议用于客户端与服务器端之间的通信，协议规定，请求从客户端发出，最后服务器端响应该请求并返回。来看一个请求报文的例子： 12GET /search.jsp HTTP/1.1Host: g.hxgoogle.com 起始行的GET是一个HTTP动词，也称为方法（method），它可以指定请求的资源按期望产生某种行为，随后的字符串/search.jsp指明了请求访问的资源对象，称为请求URI（request-URI），HTTP/1.1即HTTP的版本号，用来提示客户端使用的HTTP协议功能。所以这段报文的意思翻译一下是这样的：请求用GET方法访问域名为g.hxgoogle.com的服务器上的/search.jsp页面资源。 一个完整的请求报文由Header和Body组成，Header包括请求方法、请求URI、协议版本、可选的请求首部字段等，Body指报文主体。下面重点介绍一下请求URI和HTTP方法。 URI和URLURI表示统一资源标识符，是Uniform Resource Identifier的缩写。RFC2396(RFC，Request for Comments，征求修正意见书，一些指定HTTP协议技术标准的文档)分别对这三个单词进行了如下定义： Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http:或ftp：）也更容易。 Resource：资源的定义是“可标识的任何东西”。资源不仅可以是单一的，也可以是个集合体。 Identifier：用来表示可标识的对象。也称为标识符。 综上所述，URI就是由某个协议方案（如http、ftp）表示的资源的定位标识符。如下列举几种URI的例子： 12345ftp://ftp.is.co.za/rfc/rfc1808.txthttp://www.ietf.org/rfc/rfc2396.txtldap://[2001:db8::7]/c=GB?objectClass?onemailto:John.Doe@example.comtel:+1-816-555-1212 URI用字符串标识某一互联网资源，而我们相对来说更熟悉的URL（UniformResource Locator，统一资源定位符）则是表示资源的地点。显然URL是URI的子集，而在我们大部分日常使用场景下，说到URL和URI的时候其实表示的是一个意思。 HTTP方法我们最常用的HTTP方法是GET和POST，这导致很多人以为HTTP方法只有GET和POST。这是不对的，这些年RESTful API非常流行，所以作为Web开发人员至少还应该知道PUT和DELETE。当然HTTP方法并不只有这么几种，下面介绍几种HTTP/1.1中的方法： GET：请求访问已被URI识别的资源，资源经服务器端解析后返回响应内容。 POST：POST在RESTful架构中一般用来创建资源。 PUT：对资源进行修改。 DELETE：删除资源。 HEAD：获得报文首部（Header），用于确认URI的有效性及资源的更新日期等。 TRACE：追踪路径。发送请求时，在请求Header中加上Max-Forwards字段，譬如Max-Forwards: 2这样，每经过一个服务器就将该数字减1，当数字为0时停止传输，最后接收到请求的服务器返回状态码200 OK响应，响应包含最初的请求内容（将HTTP请求原样返回）。 CONNECT：要求在于代理服务器通信时建立隧道，用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer， 安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。格式为CONNECT 代理服务器名:端口号 HTTP版本号。 HTTP响应HTTP响应同样可分为Header和Body，它一般长这样： 12345678HTTP/1.1 200 okDate: ...Server: .....空行(CR + LF)&lt;html&gt;...&lt;/html&gt; 第一行是状态行，包含HTTP版本、表明响应结果的状态码和原因短语。接下来是一些首部字段，一般包括响应首部字段、通用首部字段、实体首部字段和RFC里未定义的首部（Cookie等），最后是报文主体。下面重点说明一下状态码和原因短语，它们描述了本次请求的结果。 状态码状态码的第一位数字指定了响应类别，共可分为5类： 1XX：Informational（信息性状态码），表明接受的请求正在处理。 2XX：Success（成功状态码），表明请求正常处理完毕。 3XX：Redirection（重定向状态码），表明需进行附加操作以完成请求。 4XX：Client Error（客户端错误状态码），表明服务器无法处理请求。 5XX：Server Error（服务器错误状态码），表明服务器处理请求出错。 下面列举几种常见的错误码和原因短语： 200 OK：请求正常处理。 204 No Content：请求正常处理，但没有资源可返回。 206 Partial Content： 客户端进行了范围请求，服务器成功执行这部分GET请求。 301 Moved Permanently： 永久性重定向，表明该资源已被分配了新的URI。 302 Found： 临时性重定向，表明该资源暂时被分配了新的URI。 303 See Other：表明请求的资源存在另一个URI，明确要求客户端采用GET方法重定向请求资源。 304 客户端中所请求资源的缓存仍然是有效的,也就是说该资源从上次缓存到现在并没有被修改过.条件请求可以在确保客户端的资源是最新的同时避免因每次都请求完整资源给服务器带来的性能问题. 400 Bad Request：请求报文中存在语法错误，需修改请求内容后再次发送。 401 Unauthorized*：请求需包含通过HTTP认证（BASIC认证、DIGEST认证等）的认证信息，浏览器初次接收401响应会弹出认证窗口。若之前已进行过一次请求，则表示用户认证失败。 403 Forbidden：请求资源的访问被服务器拒绝。服务器端没有必要给出拒绝的详细理由，不过也可以在响应主体部分对原因进行描述。未获得文件系统的访问授权（比如在IIS上部署网站时默认不能通过浏览器访问文件）、访问权限出现问题（比如从未授权的发送源IP地址试图访问）都有可能返回403响应。 404 Not Found：服务器无法找到请求的资源（也可在服务器端拒绝访问且不想说明理由时使用）。 500 Internal Server Error：服务器端执行请求时发生内部错误。多为服务器端程序出现Bug。 503 Service Unavailable：服务器处于超负载或正在停机维护，暂时无法处理请求。 HTTP协议的一些特性HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。这在当年都是一些小容量文本传输的情况下是可行的，但随着HTTP的普及，传输过程中包含大量图片的情况多了起来。譬如使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问该HTML页面资源的同时，也会请求该页面包含的其他资源如各种不同的图片，它们是在不同服务器上的。如果每次请求都得重新建立一次TCP连接的话，无疑会增加通信量的开销，而且频繁断开又重连会导致页面加载缓慢，影响用户体验。 持久连接（HTTP Persistent Connections）为了解决上述问题，HTTP/1.1和一部分HTTP/1.0开始支持持久连接。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。HTTP/1.1中所有的连接默认都是持久连接。 管线化（pipelining）持久连接使得多数请求以管线化方式发送成为可能。以往发送请求后需等待并收到响应后才能发送下一个请求，管线化技术出现后，无需等待亦可发送下一个请求。这就实现了多个请求的并行发送，提高了网络通信效率。 CookieHTTP是无状态协议，它不对之前发生过的请求和响应状态进行管理。无状态自然可以减少服务器的CPU及内存资源消耗，但有些时候我们又需要对过去的状态进行管理，譬如登录验证之后用户在浏览该网站其他网页时应该保持登录的状态而不是重新进行登录。当然要实现状态管理，我们可以使用很多方法，无外乎是在服务器端和客户端都保存一个凭证，之后每次请求都带上这个凭证，然后在服务器端进行比对，获取状态信息。HTTP协议中引入的Cookie技术，也是为了解决状态管理问题，采用的方法也跟我上面说的差不多，只不过这是发生在协议层面，不需要自己写很多代码管理。 具体来说，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态，过程如下： 客户端第一次发送请求，请求报文中没有Cookie信息。 服务器端生成Cookie信息，在响应报文中通过Set-Cookie这个首部字段，通知客户端保存Cookie，大概长这样： 1234HTTP/1.1 200 ok...&lt;Set-Cookie: sid=1345077140226724;path=/;expires=Fri,=&gt;23-Oct-15 07:12:20 GMT&gt;Content-Type: text/plain; charset=UTF-8 客户端再次发送请求时，自动在请求报文中加入Cookie值后发送出去。大概长这样： 123GET /image/ HTTP/1.1Host: github.comCookie: sid=1345077140226724 服务器端收到Cookie信息后，会去检查从哪个客户端发来的连接请求，然后对比服务器上的记录，得到之前的状态信息。 参考连接 HTTP知识点总结 [译]理解HTTP/304响应","tags":[{"name":"http","slug":"http","permalink":"http://woshijingshenbing.com/tags/http/"}]},{"title":"Markdown使用手册","date":"2015-06-03T02:11:12.000Z","path":"2015/06/03/Markdown使用手册/","text":"个人博客第一篇文章，用 Markdown 写的，尽管有点小麻烦，但慢慢就会熟悉起来的，这里把常用方法做一个总结。 首行缩进在段首加入&amp;ensp;来输入一个空格.加入&amp;emsp; &amp;emsp;来输入两个空格。 插入代码 在代码两侧加入一个反引号 ` (单行代码) 在代码两侧添加三个反引号 ``` （多行代码） 反引号最好在代码的前后行添加，而不是直接加在代码两边 添加空行可以结束先前的格式状态。建议在改变格式时，均添加一个空行。 代码区块以原来的样子来展示：缩进四个空格，一个代码区块会一直持续到没有缩进的那一行（或是文件结尾） 列表 用 * 来代表无序列表 直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符 如果要在列表项目内放进引用，那 &gt; 就需要缩进 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符 引用在文本前加入 &gt; 这种尖括号（大于号） 链接（图片）插入链接与插入图片的语法很像，区别在一个 ! 号。到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 图片：![]() 链接：[]() 参考式链接I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 行内式链接：(不建议使用)I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 粗体和斜体 用两个 * 包含一段文本就是 粗体 的语法，用一个 * 包含一段文本就是 斜体 的语法 如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线 分割线用三个 * 或者 _来表示， 不过建议用一整行 _ 来表示，易于辨识 插入表格目前编辑器不支持表格，以往是通过截图，呈现的效果并不好，Markdown支持html，所以我们可以用html来写表格。但是用html写表格，实在太麻烦了，这里有个简单的转换方法，参考Markdown之表格的处理 兼容 HTMLHTML 是一种发布的格式，Markdown 是一种书写的格式。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp; 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 换行Markdown 允许段落内的强迫换行（插入换行符），如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 参考连接 Markdown 语法说明 (简体中文版)","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://woshijingshenbing.com/tags/Markdown/"}]}]